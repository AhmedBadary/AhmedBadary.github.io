---
layout: hw
title: The Generalized Max Sub-Array Problem
permalink: /max_subarr
prevLink: /work_files/research/conv_opt.html
date: 12/06/2017
course: AiFi
number: Steve Gu
---


# Max sum sub-array (1-D)

## **Brute Force**
{: style="color: SteelBlue"}

Simply, we have to check all the possible combinations of (contiguous) subarrays.  
We achieve that by a double for loop that grows the size of the subarray and moves it along while keeping track of the max sum and the respective indices that achieved the maximum value.  

**_Runtime:_** $$\mathcal{O}(n^2)$$  

```python
def max_subarr(A):
    max_sum = 0
    ind_i = 0
    ind_j = 0
    for i in range(len(A)):
        total = 0
        for j in range(i, len(A)):
            total += np.sum(A[j])
            if total > max_sum:
                max_sum = total
                ind_i = i
                ind_j = j
```

## **Recursion**
{: style="color: SteelBlue"}

We could approach this problem from a recrusive perspective by dividing the problem into sub-problems.  
We utilize an idea from "MergeSort" and break the array into sub-arrays of which we compute and compare their sums. then we save the sub-array that has the max sum.  
We finally compare that to the sub-array that includes both halves overlapping in the middle.

**_Runtime:_** $$\mathcal{O}(n)$$  

```python
def max_subarr(A, start_ind, end_ind):
    mid = (start_ind + end_ind - 1) / 2
    l_sum, l_i, l_j = max_subarr(A, start_ind, mid)
    r_sum, l_i, r_j = max_subarr(A, mid+1, end_ind)
    i = min(minPLeft, minPRight) # Min of the sums in [start−1, ..., end−1]
    j = max(maxPLeft, maxPRight) # Max of the sums in [start, ..., end]
    c_sum = r_j - l_i # Considering the center and overlap
    M = max(l_sum, r_sum, c_sum)
    return M, i, j
```

## **Dynamic Programming**
{: style="color: SteelBlue"}

We smartly look at all the sets of subarrays that end with a given index "$$i$$". If we can do that effeciently enough then we will be able to replicate the performance of the recursive algorithm.  

Let $$A_i$$ be  the maximum subarray sum ending at position $$i$$.  
Now, we consider the sub-problem, what does $$A_{i+1}$$ equal to? what if I already have the solution to $$A_i$$?  
Simply, 
<p> $${\displaystyle A_{i+1}=max(A[i+1] + A_{i}, A[i+1])} {\displaystyle B_{i+1}=max(A_{i+1},A_{i+1}+B_{i})}$$</p>
> i.e. The maximum subarray sum ending at position $$i+1$$ either will be the singlton element at the $$i+1$$-st position or will be that added to the maximum subarray sum ending at position $$i$$, $$A_i$$.  

Now, if we realize that all we need is to consider the ending indices is just to go over the whole array and grow as needed, we realize that we can do it all in one pass!  
$$\implies$$  

**_Runtime:_** $$\mathcal{O}(n)$$  

```python
def max_subarr(A):
    grow_el = A[0]
    max_sum = A[0]
    i = j = c = 0
    for ind in range(1, len(A)):
        i = c if max_sum < grow_el else pass
        j = j if max_sum < grow_el else pass
        grow_el = max(A[ind], grow_el + A[ind])
        max_sum = max(max_sum, grow_el)
        c = i+1 if grow_el < 0 else pass
    return max_sum
```

***

# Max sum sub-matrix (2-D)

## **Brute Force**
{: style="color: SteelBlue"}

In the 2D case, we could still use a naive approach and try all the possible kernel sizes and just compute a convolution amongst all these kernels.  
We will need to make all the possible kernel sizes, there are $$n^4$$ of them. For each one of those we need to compute a convolution over the whole matrix, which in turn takes $$\mathcal{O}(n^2)$$,   
$$\implies$$  

**_Runtime:_** $$\mathcal{O}(n^6)$$  

```python
def max_submat(A):
    max_sum = Integer.MIN_VALUE;
    max_ri = max_ci = max_rj = max_cj = -1

    for ri in range(len(A)):
        for ci in range(len(A)):
            for rj in range(len(A)):
                for cj in range(len(A)):
                    sum = 0
                    for i in range(rj):
                        for j in range(cj):
                            sum += A[i][j]
                    if max_sum < sum:
                        max_sum = sum
                        max_ri = ri
                        max_ci = ci
                        max_rj = rj
                        max_cj = cj
    return max_sum
```

## **Dynamic Programming**
{: style="color: SteelBlue"}