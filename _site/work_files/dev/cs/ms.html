<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta charset="UTF-8">
  <title>Ahmad Badary</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/cayman.css">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="shortcut icon" href="/main_files/favicon.ico" />
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="/css/customStyle.css">
  <title> » Ahmad Badary</title>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
</head>

  <body>
    <nav class="main-nav">
    <a href="https://ahmedbadary.github.io/" class="main-nav-logo">
        <img src="/main_files/logo.png">
    </a>
    <ul id="menu-main" class="main-nav-items">
        <li id="menu-item-1859" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-home menu-item-1859">
            <a href="/">Home</a>
        </li>
        <li id="menu-item-2869" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2869">
            <a href="/work">Work</a>
        </li>
        <li id="menu-item-1892" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-1892">
            <a href="/projects">Projects</a>
        </li>
        <li id="menu-item-1858" class="menu-item menu-item-type-post_type menu-item-object-page current_page_parent menu-item-1858">
            <a href="/blog">Blog</a>
        </li>
        <li id="menu-item-1862" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-1862">
            <a href="/about">About</a>
        </li>
    </ul>
</nav>


<section class="page-header">
  <h1 class="project-name">Memory Safety <br /> Vulnerabilities and Prevention</h1>
  <h2 class="project-tagline"></h2>
  <a href="/work_files/school.html" class="btn">Courses</a>
  <a href="/work_files/school/128a.html" class="btn">Chapters</a>
  <a href= /work_files/dev/cs.html class="btn">This Chapter</a>
</section>

<!-- <div>
  <ul class="posts">
    
      <li><span>02 Jan 2014</span> &raquo; <a href="/2014/01/02/introducing-Ahmad/">Introducing Ahmad</a></li>
    
  </ul>
</div> -->


    <section class="main-content">
      
      <div class="TOC">
  <h1 id="table-of-contents">Table of Contents</h1>

  <ul class="TOC1">
    <li><a href="#content1">Buffer Overflow Vulnerabilities</a></li>
  </ul>
  <ul class="TOC2">
    <li><a href="#content2">Stack smashing</a></li>
  </ul>
  <ul class="TOC3">
    <li><a href="#content3">Format String Vulnerabilities</a></li>
  </ul>
  <ul class="TOC4">
    <li><a href="#content4">Integer Conversion Vulnerabilities</a></li>
  </ul>
  <ul class="TOC5">
    <li><a href="#content5">Other Vulnerabilities</a></li>
  </ul>
  <ul class="TOC6">
    <li><a href="#content6">Defending against Memory-Vulnerabilities</a></li>
  </ul>
</div>

<hr />
<hr />

<h2 id="memory-safety"><strong style="color: SteelBlue  " class="bodyContents1" id="bodyContents11">Memory Safety:</strong></h2>
<p class="message">
Ensuring the integrity of a programs data structures by preventing users (attackers) from reading and writing to memory at will (location- and time- wise).
</p>

<h2 id="content1">Buffer Overflow Vulnerabilities</h2>

<ol>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue  " class="bodyContents1" id="bodyContents11">What?</strong></dt>
      <dd>A buffer overflow bug is one where the programmer fails
to perform adequate bounds checks, triggering an out-of-bounds memory access that writes
beyond the bounds of some memory region.</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue  " class="bodyContents1" id="bodyContents12">How?</strong></dt>
      <dd>Attackers can use these out-of-bounds memory accesses to corrupt the program’s intended behavior.</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue  " class="bodyContents1" id="bodyContents13">Why? (Who’s at risk?)</strong></dt>
      <dd>This is a common problem with the language C.</dd>
      <dd>C, has no “automatic Bounds Checking” for array or pointer access.</dd>
    </dl>
  </li>
  <li><strong style="color: SteelBlue  " class="bodyContents1" id="bodyContents14">Example:</strong>
    <ol>
      <li>In this example, gets() reads as many bytes of input as are available on standard input, and stores them into buf[]. If the input contains more than 80 bytes of data, then gets() will write past the end of buf, overwriting some other part of memory.
        <div class="language-c highlighter-rouge"><pre class="highlight"><code> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
 <span class="kt">void</span> <span class="nf">vulnerable</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">gets</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre>
        </div>
        <blockquote>
          <p>This is a bug. This bug typically causes a crash and a core-dump.</p>
        </blockquote>
      </li>
      <li>Unfortunately, the authenticated flag is stored in memory right after <code class="highlighter-rouge">buf</code>. If the attacker can write 81 bytes of data to buf (with the 81st byte set to a non-zero value), then this will set the authenticated flag to true, and the attacker will gain access.
        <div class="language-c highlighter-rouge"><pre class="highlight"><code> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
 <span class="kt">int</span> <span class="n">authenticated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="kt">void</span> <span class="nf">vulnerable</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">gets</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre>
        </div>
        <blockquote>
          <p>An attacker who can control the input to the program can bypass the password checks.</p>
        </blockquote>
      </li>
      <li>The function pointer <code class="highlighter-rouge">fnptr</code> is invoked elsewhere in the program (not shown). This enables a more serious attack: the attacker can overwrite fnptr with any address of their choosing, redirecting program execution to some other memory location.
        <div class="language-c highlighter-rouge"><pre class="highlight"><code> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
 <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fnptr</span><span class="p">)();</span>
 <span class="kt">void</span> <span class="nf">vulnerable</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">gets</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre>
        </div>
        <blockquote>
          <p>A crafty attacker could supply an input that consists of malicious machine instructions, followed by a few bytes that overwrite fnptr with some address A.
 When fnptr is next invoked, the flow of control is redirected to address A.</p>
          <blockquote>
            <p>Of course, many variations on this attack are possible:<br />
for instance, the attacker could arrange to store the malicious code anywhere else  e.g., in some other input buffer), rather than in buf, and redirect execution to that other location.</p>
          </blockquote>
        </blockquote>
      </li>
    </ol>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue  " class="bodyContents1" id="bodyContents15">Comments on Buffer Overflows as a Secuirty Vulnerability:</strong></dt>
      <dd>Buffer overflow vulnerabilities and malicious code injection are a favorite method used by worm writers and attackers.</dd>
    </dl>
  </li>
  <li><strong style="color: SteelBlue  " class="bodyContents1" id="bodyContents16">Mitigation:</strong>
    <ol>
      <li>Is it possible to prevent the attacker from overwriting the return address on the stack to change the control flow? Can we, at least, detect it?
        <ul>
          <li><strong>Solution:</strong><br />
  <strong>Stack Canaries:</strong> A canary or canary word is a known value placed between the local variables and control data on the stack. Before reading the return address, code inserted by the compiler checks the canary against the known value. Since a successful buffer overflows needs to overwrite the canary before reaching the return address, and the attacker cannot predict the canary value, the canary validation will fail and stop execution prior to the jump.
            <div class="language-c highlighter-rouge"><pre class="highlight"><code>      <span class="cm">/* This number is randomly set before each run. */</span>
      <span class="kt">int</span> <span class="n">MAGIC</span> <span class="o">=</span> <span class="n">rand</span><span class="p">();</span>
      <span class="kt">void</span> <span class="nf">vuln</span><span class="p">()</span> <span class="p">{</span>
          <span class="kt">int</span> <span class="n">canary</span> <span class="o">=</span> <span class="n">MAGIC</span><span class="p">;</span>
          <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
          <span class="n">gets</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">canary</span> <span class="o">!=</span> <span class="n">MAGIC</span><span class="p">)</span>
              <span class="n">HALT</span><span class="p">();</span>
      <span class="p">}</span>
</code></pre>
            </div>
          </li>
          <li><strong>Limitations:</strong>
            <ol>
              <li>Canaries only protect against stack smashing attacks, not against heap overflows or format string vulnerabilities.</li>
              <li>Local variables, such as function pointers and authentication flags, can still be overwritten.</li>
              <li>No protection against buffer underflows. This can be problematic in combination with the previous point.</li>
              <li>If the attack occurs before the end of the function, the canary validation does not even take place. This happens for example when an exception handler on the stack gets invoked before the function returns.</li>
            </ol>
          </li>
          <li><strong>Cost:</strong><br />
  The canary has to be validated on each function return. The performance overhead is only a few percent since a canary is only needed in functions with local arrays.</li>
        </ul>
      </li>
      <li>The overwritten return address must point to a valid instruction sequence. The attacker often places the malicious code to execute in the vulnerable buffer. However, the buffer address must be known to set up the jump target correctly. One way to find out this address is to observe the program in a debugger.<br />
 What could be done to make it harder to accurately find out the address of the start of the malicious code?
        <ul>
          <li><strong>Solution:</strong><br />
  <strong>Address Randomization:</strong> When the OS loader puts an executable into memory,   it maps the different sections (text, data/BSS, heap, stack) to fixed memory-safetylocations. In the mitigation technique called address space layout Randomization(ASLR), rather than deterministically allocating the process layout, the OS randomizes the starting base of each section.
            <blockquote>
              <p>For instance, the OS might decide to start stack frames from somewhere other than the highest memory address.</p>
            </blockquote>
          </li>
          <li><strong>Limitations:</strong>
            <ol>
              <li>Entropy reduction attacks can significantly lower the efficacy of ASLR.
                <blockquote>
                  <p>For example, reducing factors are page alignment requirements (stack: 16 bytes, heap: 4096 bytes).</p>
                </blockquote>
              </li>
              <li>Address space information disclosure techniques can force applications too leak known addresses.</li>
              <li>Revealing addresses via brute-forcing can also be an effective techniques when an application does not terminate.
                <blockquote>
                  <p>e.g., when a block that catches exceptions exists.</p>
                </blockquote>
              </li>
              <li>Techniques known as heap spraying and JIT spraying allow an attacker to inject code at predictable locations.</li>
            </ol>
          </li>
          <li><strong>Cost:</strong><br />
  The overhead incurred by ASLR is negligible.</li>
        </ul>
      </li>
      <li>Attackers often store their malicious code inside the same buffer that they overflow.
 What mechanism could prevent the execution of the malicious code? What type of
 code would break with this defense in place?
        <ul>
          <li><strong>Solution:</strong><br />
  <strong>Executable Space Protection:</strong> Modern CPUs include a feature to mark certain memory regions non-executable. AMD calls this feature the NX (no execute) bit and Intel the XD (execute disable) bit. The idea is to combat buffer overflows where the attacker injects their own code.
            <blockquote>
              <p>For instance, the OS might decide to start stack frames from somewhere other than the highest memory address.</p>
            </blockquote>
          </li>
          <li><strong>Limitations:</strong>
            <ol>
              <li>An attacker does not have to inject their own code. It is also possible to leverage existing instruction sequences in memory and jump to them. See part 3 for details.</li>
              <li>The defense mechanism disallows execution of code generated at runtime, such as during JIT compilation or self-modifying code (SMC).</li>
              <li>If code is loaded at predictable addresses, it is possible to turn non-executable into executable code
                <blockquote>
                  <p>e.g.,  via system functions like VirtualAlloc or VirtualProtect on Windows</p>
                </blockquote>
              </li>
            </ol>
          </li>
          <li><strong>Cost:</strong><br />
  There is no measurable overhead due to the hardware support of modern CPUs.</li>
        </ul>
      </li>
    </ol>
  </li>
</ol>

<hr />

<h2 id="content2">Stack smashing</h2>
<ul>
  <li><a href="/work_files/web_dev/security/ms#bodyContents24">BackGround: Memory Layout, Convention, and Protocol in (Intel (x86))</a></li>
</ul>

<ol>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue  " class="bodyContents2" id="bodyContents21">What?</strong></dt>
      <dd>When a <em>stack frame</em> is pushed on the stack (e.g. a function stack frame), a certain amount of memory is allocated for the inputs. If the input is actually bigger than the memory allocated for it, then it will overflow and will overwrite the stack pointer (SP) and the return address.</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue  " class="bodyContents2" id="bodyContents22">How?</strong></dt>
      <dd>Stack smashing can be used for malicious code injection.</dd>
    </dl>
    <ul>
      <li>First, the attacker arranges to infiltrate a malicious code sequence somewhere in the program’s address space, at a known address (perhaps using techniques previously mentioned).</li>
      <li>Next, the attacker provides a carefully-chosen 88-byte input, where the last four bytes hold the address of the malicious code.</li>
      <li>The gets() call will overwrite the return address on the stack with the last 4 bytes of the input—in other words, with the address of the malicious code.</li>
      <li>When vulnerable() returns, the CPU will retrieve the return address stored on the stack and transfer control to that address, handing control over to the attacker’s malicious code.</li>
    </ul>
  </li>
  <li><strong style="color: SteelBlue  " class="bodyContents2" id="bodyContents23">Example:</strong> <br />
    <ol>
      <li>In this example,     When vulnerable() is called, a stack frame is pushed onto the stack. The stack will look something like this:
 <img src="/main_files/web_dev/images/e2.png" alt="img" width="87%" /> <br />
 If the input is too long, the code will write past the end of buf and the saved SP and return address will be overwritten.
        <div class="language-c highlighter-rouge"><pre class="highlight"><code> <span class="kt">void</span> <span class="nf">vulnerable</span><span class="p">()</span> <span class="p">{</span>
     <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
     <span class="n">gets</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre>
        </div>
      </li>
    </ol>
  </li>
  <li><strong style="color: SteelBlue  " class="bodyContents2" id="bodyContents24">Memory Layout:</strong> <br />
    <ul>
      <li><strong>The Text:</strong> region contains the executable code of the program.</li>
      <li><strong>The Heap:</strong> stores dynamically allocated data (and grows and shrinks as objects are allocated and freed).</li>
      <li><strong>The Stack:</strong> stores local variables and other information associated with each function call (which grows and shrinks with function calls and returns).</li>
    </ul>

    <blockquote>
      <p>In the picture above, the text region starts at smaller-numbered memory addresses (e.g., 0x00..0), and the stack region ends at larger-numbered memory addresses (0xFF..F).</p>
    </blockquote>
  </li>
  <li><strong style="color: SteelBlue  " class="bodyContents2" id="bodyContents25">Convention and Protocol:</strong> <br />
 <button class="showText" value="show" onclick="showTextPopHide(event);">Show List</button>
 <img src="/main_files/web_dev/images/lst.png" alt="img" width="87%" hidden="" /></li>
</ol>

<hr />

<h2 id="content3">Format String Vulnerabilities</h2>

<ol>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue  " class="bodyContents3" id="bodyContents31">What?</strong></dt>
      <dd>A vulnerability caused by unchecking the format of the user input which can leave the system vulnerabule to crashing or injection.</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue  " class="bodyContents3" id="bodyContents32">How?</strong></dt>
      <dd>A malicious user may use the <code class="highlighter-rouge">%s</code> and <code class="highlighter-rouge">%x</code> format tokens, among others, to print data from the call stack or possibly other locations in memory. One may also write arbitrary data to arbitrary locations using the <code class="highlighter-rouge">%n</code> format token, which commands <code class="highlighter-rouge">printf()</code> and similar functions to write the number of bytes formatted to an address stored on the stack.</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue  " class="bodyContents3" id="bodyContents33">Why? (Who’s at risk?)</strong></dt>
      <dd>The problem stems from the use of unchecked user input as the format string parameter in certain C functions that perform formatting, such as <code class="highlighter-rouge">printf()</code>.</dd>
    </dl>
  </li>
  <li><strong style="color: SteelBlue  " class="bodyContents3" id="bodyContents34">Example:</strong> <br />
    <ul>
      <li>In this example, If buf contains any <code class="highlighter-rouge">%</code> characters, <code class="highlighter-rouge">printf()</code> will look for non-existent arguments, and may crash or core-dump the program trying to chase missing pointers.
        <div class="language-c highlighter-rouge"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">vulnerable</span><span class="p">()</span> <span class="p">{</span>
      <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">buf</span><span class="p">,</span> <span class="n">stdin</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
          <span class="k">return</span><span class="p">;</span>
      <span class="n">printf</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre>
        </div>
      </li>
      <li><button class="showText" value="show" onclick="showTextPopHide(event);">More Examples</button>
 <img src="/main_files/web_dev/images/strng_frmt.png" alt="formula" hidden="" width="70%" /></li>
    </ul>
  </li>
  <li><strong style="color: SteelBlue  " class="bodyContents3" id="bodyContents35">Attack Types:</strong>
    <ul>
      <li><strong>The attacker can learn the contents of the function’s stack frame:</strong>
        <ol>
          <li>Supplying the string <code class="highlighter-rouge">"%x:%x"</code> reveals the first two words of stack memory.</li>
        </ol>
      </li>
      <li><strong>The attacker can also learn the contents of any other part of memory, as well:</strong>
        <ol>
          <li>Supplying the string <code class="highlighter-rouge">"%s"</code> treats the next word of stack memory as an address, and prints the string found at that address.</li>
          <li>Supplying the string <code class="highlighter-rouge">"%x:%s"</code> treats the next word of stack memory as an address, the word after that as an address, and prints what is found at that string.</li>
          <li>To read the contents of memory starting at a particular address, the attacker can find a nearby place on the stack where that address is stored, and then supply just enough <code class="highlighter-rouge">%x</code>’s to walk to this place followed by a <code class="highlighter-rouge">%s</code>.</li>
          <li>Thus, an attacker can exploit a format string vulnerability to learn passwords, cryptographic keys, or other secrets stored in the victim’s address space.</li>
        </ol>
      </li>
      <li><strong>The attacker can write any value to any address in the victim’s memory:</strong>
        <ol>
          <li>Use <code class="highlighter-rouge">%n</code> and many tricks; the details are beyond the scope of this writeup.</li>
          <li>You might want to ponder how this could be used for malicious code injection.</li>
        </ol>
      </li>
    </ul>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue  " class="bodyContents3" id="bodyContents36">Format String:</strong></dt>
      <dd>A <strong>Format String</strong> is an ASCIIZ string that contains text and format parameters.</dd>
    </dl>
    <ul>
      <li><strong>Example:</strong>  <code class="highlighter-rouge">printf(“my name is:%s\n”,”saif”);</code>
        <blockquote>
          <p>Think of a format string as a specifier which tells the program the format of the output</p>
        </blockquote>
      </li>
      <li><strong>Types:</strong>  <br />
 <img src="/main_files/web_dev/images/table.png" alt="img" width="87%" /></li>
    </ul>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue  " class="bodyContents3" id="bodyContents37">What does the stack look like during a “printf”?</strong></dt>
      <dd>
        <blockquote>
          <p><strong>Command:</strong></p>
          <div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">this</span> <span class="n">is</span> <span class="n">a</span> <span class="o">%</span><span class="n">s</span><span class="p">,</span> <span class="n">with</span> <span class="n">a</span> <span class="n">number</span> <span class="o">%</span><span class="n">d</span><span class="p">,</span> <span class="n">and</span> <span class="n">address</span> <span class="o">%</span><span class="mi">08</span><span class="n">x</span><span class="err">”</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>
</code></pre>
          </div>
        </blockquote>
      </dd>
      <dd>
        <ul>
          <li><strong>Assumptions:</strong> The Stack grows downwards towards lower addresses and arguments are pushed in reverse on the stack, also it operates on LIFO “last in first out” bases.</li>
        </ul>
      </dd>
      <dd><img src="/main_files/web_dev/images/s1.png" alt="img" width="47%" /></dd>
      <dd>
        <ul>
          <li>What happens to the stack when a format string is specified with no corresponding variable on stack??!!</li>
        </ul>
      </dd>
      <dd><img src="/main_files/web_dev/images/s2.png" alt="img" width="57%" /></dd>
      <dd>It will start to pop data off the stack from where the variables should have been located.</dd>
    </dl>
  </li>
  <li><strong style="color: SteelBlue  " class="bodyContents3" id="bodyContents38">Format Strings Protocol:</strong>
    <ul>
      <li>The padding parameters to format specifiers are used to control the number of bytes output.</li>
      <li>The <code class="highlighter-rouge">%x</code> token is used to pop bytes from the stack until the beginning of the format string itself is reached.</li>
      <li>The start of the format string is crafted to contain the address that the %n format token can then overwrite with the address of the malicious code to execute.</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="content4">Integer Conversion Vulnerabilities</h2>

<ol>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue  " class="bodyContents4" id="bodyContents41">What?</strong></dt>
      <dd>A vulnerability that occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits – either larger than the maximum or lower than the minimum representable value.</dd>
      <dd>
        <blockquote>
          <p>The most common result of an overflow is that the least significant representable bits of the result are stored; the result is said to wrap around the maximum.</p>
        </blockquote>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue  " class="bodyContents4" id="bodyContents42">How?</strong></dt>
      <dd>An attacker can use the representation mismatch to input a very large number, effectively, overdlowing the buffer.</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue  " class="bodyContents4" id="bodyContents43">Why? (Who’s at Risk?)</strong></dt>
      <dd>The C compiler won’t warn about the type mismatch between signed int and unsigned int; it silently inserts an implicit cast.</dd>
    </dl>
  </li>
  <li><strong style="color: SteelBlue  " class="bodyContents4" id="bodyContents44">Example:</strong> <br />
    <ol>
      <li>In this example, the prototype for <code class="highlighter-rouge">memcpy()</code> is:
        <div class="language-c highlighter-rouge"><pre class="highlight"><code> <span class="kt">void</span> <span class="o">*</span><span class="n">memcpy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span> 
</code></pre>
        </div>
        <p>And the definition of <code class="highlighter-rouge">size_t</code> is:</p>
        <div class="language-c highlighter-rouge"><pre class="highlight"><code> <span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="kt">size_t</span> 
</code></pre>
        </div>
        <p>If the attacker provides a negative value for len, the if statement won’t notice anything wrong, and <code class="highlighter-rouge">memcpy()</code> will be executed with a negative third argument.<br />
 C will cast this negative value to an unsigned int and it will become a very large positive.</p>
        <div class="language-c highlighter-rouge"><pre class="highlight"><code>     <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
     <span class="kt">void</span> <span class="nf">vulnerable</span><span class="p">()</span> <span class="p">{</span>
         <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">read_int_from_network</span><span class="p">();</span>
         <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">read_string_from_network</span><span class="p">();</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">80</span><span class="p">)</span> <span class="p">{</span>
             <span class="n">error</span><span class="p">(</span><span class="s">"length too large: bad dog, no cookie for you!"</span><span class="p">);</span>
             <span class="k">return</span><span class="p">;</span>
         <span class="p">}</span>
         <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
     <span class="p">}</span>
</code></pre>
        </div>
        <blockquote>
          <p>Thus <code class="highlighter-rouge">memcpy()</code> will copy a huge amount of memory into buf, overflowing the buffer.</p>
        </blockquote>
      </li>
      <li>In this example, the code seems to avoid buffer overflow problems (by allocating 5 more bytes than necessary). But, there is a subtle problem: len+5 can wrap around if len is too large. For instance, if <code class="highlighter-rouge">len = 0xFFFFFFFF</code>, then the value of <code class="highlighter-rouge">len+5</code> is 4 (on 32-bit platforms).<br />
 In this case, the code allocates a 4-byte buffer and then writes a lot more than 4 bytes into it: a classic buffer overflow.
        <div class="language-c highlighter-rouge"><pre class="highlight"><code>     <span class="kt">void</span> <span class="nf">vulnerable</span><span class="p">()</span> <span class="p">{</span>
         <span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
         <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
         <span class="n">len</span> <span class="o">=</span> <span class="n">read_int_from_network</span><span class="p">();</span>
         <span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">len</span><span class="o">+</span><span class="mi">5</span><span class="p">);</span>
         <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
         <span class="p">...</span>
     <span class="p">}</span>
</code></pre>
        </div>
      </li>
    </ol>
  </li>
</ol>

<hr />

<h2 id="content5">Other Vulnerabilities</h2>

<ol>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue  " class="bodyContents5" id="bodyContents51">Dangling Pointers:</strong></dt>
      <dd>A pointer into a memory region that has been freed and is no longer valid.</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue  " class="bodyContents5" id="bodyContents52">Double-Free Bugs:</strong></dt>
      <dd>Happens when a dynamically allocated object is explicitly freed multiple times</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue  " class="bodyContents5" id="bodyContents53">Arc Injection:</strong></dt>
      <dd>By injecting malicious data that existing instructions later operates on, an attacker can still manipulate the execution path.</dd>
      <dd>
        <blockquote>
          <p>Recall that the <code class="highlighter-rouge">ret</code> instruction is equivalent to <code class="highlighter-rouge">popl %eip</code> <br />
i.e., it writes the top of the stack into the program counter.</p>
        </blockquote>
      </dd>
    </dl>
  </li>
</ol>

<hr />

<h2 id="content6">Defending against Memory-Vulnerabilities</h2>

<ol>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue  " class="bodyContents6" id="bodyContents61">Secure Coding Practices:</strong></dt>
      <dd>In general, before performing any potentially unsafe operation, we can write some code to check (at runtime) whether the operation is safe to perform and abort if not.</dd>
    </dl>

    <ul>
      <li><strong>Examples:</strong>
        <ol>
          <li>This code ensures that the array access will be within bounds.<br />
  Instead of:
            <div class="language-c highlighter-rouge"><pre class="highlight"><code>  <span class="kt">char</span> <span class="nf">digit_to_char</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// BAD
</span> <span class="kt">char</span> <span class="n">convert</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"0123456789"</span><span class="p">;</span>
 <span class="k">return</span> <span class="n">convert</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>
</code></pre>
            </div>
            <p>Write:</p>
            <div class="language-c highlighter-rouge"><pre class="highlight"><code> <span class="kt">char</span> <span class="nf">digit_to_char</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// BETTER
</span>     <span class="kt">char</span> <span class="n">convert</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"0123456789"</span><span class="p">;</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">)</span>
         <span class="k">return</span> <span class="s">"?"</span><span class="p">;</span> <span class="c1">// or, call exit()
</span>     <span class="k">return</span> <span class="n">convert</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
 <span class="p">}</span>
</code></pre>
            </div>
          </li>
          <li>The latter is better, because <code class="highlighter-rouge">strlcpy(d,s,n)</code> takes care to avoid writing more than <code class="highlighter-rouge">n</code> bytes into the buffer <code class="highlighter-rouge">d</code>.<br />
  Instead of:
            <div class="language-c highlighter-rouge"><pre class="highlight"><code>  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
  <span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span> <span class="c1">// BAD
</span></code></pre>
            </div>
            <p>Write:</p>
            <div class="language-c highlighter-rouge"><pre class="highlight"><code>  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
  <span class="n">strlcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">buf</span><span class="p">);</span> <span class="c1">// BETTER
</span></code></pre>
            </div>
            <blockquote>
              <p>Basically, when calling library functions, we can use a library function that incorporates these kinds of checks.</p>
            </blockquote>
          </li>
          <li>The latter is better, because <code class="highlighter-rouge">strlcpy(d,s,n)</code> takes care to avoid writing more than <code class="highlighter-rouge">n</code> bytes into the buffer <code class="highlighter-rouge">d</code>.<br />
  Instead of:
            <div class="language-c highlighter-rouge"><pre class="highlight"><code>  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span> <span class="c1">// BAD
</span></code></pre>
            </div>
            <p>Write:</p>
            <div class="language-c highlighter-rouge"><pre class="highlight"><code>  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
  <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">buf</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span> <span class="c1">// BETTER
</span></code></pre>
            </div>
            <blockquote>
              <p>Basically, when calling library functions, we can use a library function that incorporates these kinds of checks.</p>
            </blockquote>
          </li>
          <li>Instead of using <code class="highlighter-rouge">gets()</code>, we can use <code class="highlighter-rouge">fgets()</code>.</li>
        </ol>
      </li>
      <li><strong>What can we check?</strong>
        <ol>
          <li>Array indices are in-bounds before using them.</li>
          <li>Pointers are non-null and in-bounds before dereferencing them.</li>
          <li>Integer addition and multiplication won’t overflow or wrap around before performing the operation.</li>
          <li>Integer subtraction won’t underflow before performing it.</li>
          <li>Objects haven’t already been de-allocated before freeing them.</li>
          <li>Memory is initialized before being used.</li>
        </ol>
      </li>
    </ul>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue  " class="bodyContents6" id="bodyContents62">Defensive Programming:</strong></dt>
      <dd>
        <ul>
          <li>It is a form of defensive design intended to ensure the continuing function of a piece of software under unforeseen circumstances.
            <blockquote>
              <p>Defensive programming is like defensive driving:</p>
              <blockquote>
                <p>The idea is to avoid depending on anyone else around you, so that if anyone else does something unexpected, you won’t crash.</p>
              </blockquote>
            </blockquote>
          </li>
        </ul>
      </dd>
      <dd>
        <ul>
          <li>Defensive programming means that each module takes responsibility for checking the validity of all inputs sent to it.
            <blockquote>
              <p>Even if you “know” that your callers will never send you a NULL pointer, you check for NULL anyway (because it might change).</p>
            </blockquote>
          </li>
        </ul>
      </dd>
      <dd>
        <ul>
          <li><strong>Issues:</strong> It shouldn’t be used as the only means of defence because it assumes that the programmer will make no errors.</li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue  " class="bodyContents6" id="bodyContents63">Better Languages and Libraries:</strong></dt>
      <dd>Languages and libraries can help avoid memory-safety vulnerabilities by eliminating the opportunity for programmer mistakes.</dd>
      <dd>
        <ul>
          <li><strong>For instance:</strong>
            <ol>
              <li>Java performs automatic bounds-checking on every array access, so programmer error cannot lead to an array bounds violation.</li>
              <li>Java provides a String class with methods for many common string operations that are memory-safe.
                <blockquote>
                  <p>The method itself performs all necessary runtime checks and resizes all buffers as needed to ensure there is enough space for strings.</p>
                </blockquote>
              </li>
              <li>C++ provides a safe string class.</li>
            </ol>
          </li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue  " class="bodyContents6" id="bodyContents64">Runtime Checks:</strong></dt>
      <dd>Compilers and other tools can reduce the burden on programmers by automatically introducing runtime checks at every potentially unsafe operation, so that programmers do not have to do so explicitly.</dd>
      <dd>
        <ul>
          <li><strong>Issues with adding Runtime Checks to C:</strong>
            <ol>
              <li>Automatic bounds-checking for C/C++ has a non-trivial performance overhead.</li>
              <li>Legacy code must be recompilied; thus, must be available and must be not too “out-dated” so that it DOES compile.</li>
            </ol>
          </li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue  " class="bodyContents6" id="bodyContents65">Static Analysis:</strong></dt>
      <dd>Static analysis is a technique for scanning source code to try to automatically detect potential bugs.</dd>
      <dd>You can think of static analysis as runtime checks, performed at compile time:<br />
the static analysis tool attempts to predict whether there exists any program execution under which a runtime check would fail, and if it finds any, it warns the programmer.</dd>
      <dd>
        <ul>
          <li><strong>Advantages:</strong>
            <ol>
              <li>It can detect bugs proactively, at development time, so that they can be fixed before the code has been shipped.</li>
              <li>Makes fixing bugs cheaper because, the earlier a bug is found, the cheaper it can be to fix.</li>
            </ol>
          </li>
        </ul>
      </dd>
      <dd>
        <ul>
          <li><strong>Issues with adding Runtime Checks to C:</strong>
            <ol>
              <li>
                <p><strong>Fundamental Theorem:</strong> detecting security bugs can be shown to be undecidable (like the Halting Problem).<br />
   So it follows that any static analysis tool will either miss some bugs (false negatives), or falsely warn about code that is correct (false positives), or both.</p>
              </li>
              <li>
                <p><strong>They make Errors:</strong> from above.</p>
              </li>
            </ol>
          </li>
        </ul>
      </dd>
      <dd>
        <ul>
          <li><strong>Tradeoff:</strong> the effectiveness of a static analysis tool is determined by its false negative rate and false positive rate; these two can often be traded off against each other.
            <blockquote>
              <p>At one extreme are verification tools, which are guaranteed to be free of false negatives:</p>
              <blockquote>
                <p>if your code does not trigger any warnings, then it is guaranteed to be free of bugs (at least, of the sort of bugs that the tool attempts to detect).</p>
              </blockquote>
            </blockquote>

            <blockquote>
              <p>In practice, most developers accept a significant rate of false negatives in exchange for finding some relevant bugs, without too many false positives.</p>
            </blockquote>
          </li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue  " class="bodyContents6" id="bodyContents66">Testing:</strong></dt>
      <dd>
        <ul>
          <li><strong>Fuzz testing:</strong> is one simple form of security testing. Fuzz testing involves testing the program with random inputs and seeing if the program exhibits any sign of failure.
            <blockquote>
              <p>Usually, fuzz testing involves generating many inputs: <br />
e.g., hundreds of thousands or millions.</p>
            </blockquote>

            <blockquote>
              <p>Fuzz testing is popular in industry today because it is cheap, easy to apply, and somewhat effective at finding some kinds of bugs.</p>
            </blockquote>
          </li>
        </ul>
      </dd>
      <dd>
        <ul>
          <li><strong>Aspects of Testing for Security:</strong>
            <ol>
              <li><strong>Test Generation:</strong> We need to find a way to generate test cases, so that we can run the program on those test cases.
                <ul>
                  <li><strong>Random inputs:</strong> Construct a random input file, and run the program on that input.<br />
 The file is constructed by choosing a totally random sequence of bytes, with no structure.</li>
                  <li><strong>Mutated inputs:</strong> Start with a valid input file, randomly modify a few bits in the file, and run the program on the mutated input.</li>
                  <li><strong>Structure-driven input generation:</strong> Taking into account the intended format of the input, devise a program to independently “fuzz” each field of the input file.
                    <blockquote>
                      <p>For instance, if we know that one part of the input is a string, generate random strings (of random lengths, with random characters, some of them with % signs to try to trigger format string bugs, some with funny Unicode characters, etc.). <br />
If another part of the input is a length, try random integers, try a very small number, try a very large number, try a negative number (or an integer whose binary representation has its high bit set).</p>
                    </blockquote>

                    <blockquote>
                      <p>One issue with <em>random inputs</em> is that, if the input has a structured format, then it is likely that a random input file will not have the proper format and thus will be quickly rejected by the program, leaving much of the code uncovered and untested.</p>
                      <blockquote>
                        <p>The other two  approaches address this problem.</p>
                      </blockquote>
                    </blockquote>
                  </li>
                </ul>
              </li>
              <li><strong>Bug Detection:</strong> We need a way to detect whether a particular test case revealed a bug in the program.</li>
            </ol>
          </li>
        </ul>
      </dd>
    </dl>
  </li>
</ol>


      <footer class="site-footer">
    <!--   <span class="site-footer-owner"><a href="http://localhost:8889">Ahmad Badary</a> is maintained by <a href="http://ahmedbadary.ml">Ahmad Badary</a>.</span> -->
    
<!--  -->
    <div class="wrapper">
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
            <span class="site-footer-owner"><a href="http://localhost:8889">Site</a> maintained by <a href="http://ahmedbadary.ml">Ahmad Badary</a>.</span>
    <span class="site-footer-credits">
        <p>
            &copy; 2017. All rights reserved.
        </p> 
    </span>
            </div>
            <div class="footer-col footer-col-2">
            <div><p>         </p></div>
            </div>
            <div class="footer-col footer-col-3">
                <ul class="social-media-list">
                    
                      <li>
                        <a href="https://github.com/AhmedBadary">
                          <i class="fa fa-github"></i> GitHub
                        </a>
                      </li>
                    
                    
                      <li>
                        <a href="https://linkedin.com/in/ahmad-badary-656098121/">
                          <i class="fa fa-linkedin"></i> LinkedIn
                        </a>
                      </li>
                    
                    
                      <li>
                        <a href="https://www.facebook.com/ahmed.thabet.94">
                          <i class="fa fa-facebook"></i> Facebook
                        </a>
                      </li>
                    
                </ul>
            </div>
        </div>
    </div>
<!--  -->
</footer>


    </section>

  </body>

<!-- Table of Content Script -->
<script type="text/javascript">
var bodyContents = $(".bodyContents1");
$("<ol>").addClass("TOC1ul").appendTo(".TOC1");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC1ul");
     });
// 
var bodyContents = $(".bodyContents2");
$("<ol>").addClass("TOC2ul").appendTo(".TOC2");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC2ul");
     });
// 
var bodyContents = $(".bodyContents3");
$("<ol>").addClass("TOC3ul").appendTo(".TOC3");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC3ul");
     });
//
var bodyContents = $(".bodyContents4");
$("<ol>").addClass("TOC4ul").appendTo(".TOC4");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC4ul");
     });
//
var bodyContents = $(".bodyContents5");
$("<ol>").addClass("TOC5ul").appendTo(".TOC5");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC5ul");
     });
//
var bodyContents = $(".bodyContents6");
$("<ol>").addClass("TOC6ul").appendTo(".TOC6");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC6ul");
     });
//
var bodyContents = $(".bodyContents7");
$("<ol>").addClass("TOC7ul").appendTo(".TOC7");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC7ul");
     });
//
var bodyContents = $(".bodyContents8");
$("<ol>").addClass("TOC8ul").appendTo(".TOC8");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC8ul");
     });
//
var bodyContents = $(".bodyContents9");
$("<ol>").addClass("TOC9ul").appendTo(".TOC9");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC9ul");
     });

</script>

<!-- VIDEO BUTTONS SCRIPT -->
<script type="text/javascript">
  function iframePopInject(event) {
    var $button = $(event.target);
    // console.log($button.parent().next());
    if ($button.attr('value') == 'show') {
        $button.attr('value', 'hide');
        $figure = $("<div>").addClass("video_container");
        $iframe = $("<iframe>").appendTo($figure);
        $iframe.attr("src", $button.attr("src"));
        // $iframe.attr("frameborder", "0");
        $iframe.attr("allowfullscreen", "true");
        $iframe.css("padding", "4px 6px");
        $button.next().css("display", "block");
        $figure.appendTo($button.next());
        $button.text("Hide Video")
    } else {
        $button.attr('value', 'show');
        $button.next().html("");
        $button.text("Show Video")
    }
}
</script>

<!-- BUTTON TRY -->
<script type="text/javascript">
  function iframePopA(event) {
    event.preventDefault();
    var $a = $(event.target).parent();
    console.log($a);
    if ($a.attr('value') == 'show') {
        $a.attr('value', 'hide');
        $figure = $("<div>");
        $iframe = $("<iframe>").addClass("popup_website_container").appendTo($figure);
        $iframe.attr("src", $a.attr("href"));
        $iframe.attr("frameborder", "1");
        $iframe.attr("allowfullscreen", "true");
        $iframe.css("padding", "4px 6px");
        $a.next().css("display", "block");
        $figure.appendTo($a.next().next());
        // $a.text("Hide Content")
        $('html, body').animate({
            scrollTop: $a.offset().top
        }, 1000);
    } else {
        $a.attr('value', 'show');
        $a.next().next().html("");
        // $a.text("Show Content")
    }

    $a.next().css("display", "inline");
}
</script>


<!-- TEXT BUTTON SCRIPT - INJECT -->
<script type="text/javascript">
  function showTextPopInject(event) {
    var $button = $(event.target);
    var txt = $button.attr("input");
    console.log(txt);
    if ($button.attr('value') == 'show') {
        $button.attr('value', 'hide');
        $p = $("<p>");
        $p.html(txt);
        $button.next().css("display", "block");
        $p.appendTo($button.next());
        $button.text("Hide Content")
    } else {
        $button.attr('value', 'show');
        $button.next().html("");
        $button.text("Show Content")
    }

}
</script>

<!-- TEXT BUTTON SCRIPT - HIDDEN / HIDE / SHOW / HIDE/SHOW -->
<script type="text/javascript">
  function showTextPopHide(event) {
    var $button = $(event.target);
    var txt = $button.attr("input");
    if ($button.attr('value') == 'show') {
        $button.attr('value', 'hide');
        $button.next().removeAttr("hidden");
        $button.text("Hide Content");
    } else {
        $button.attr('value', 'show');
        $button.next().attr("hidden", "");
        $button.text("Show Content");
    }
}
</script>

<!-- TEXT BUTTON SCRIPT - HIDDEN / HIDE / SHOW / HIDE/SHOW -->
<script type="text/javascript">
  function showText_withParent_PopHide(event) {
    var $button = $(event.target);
    var $parent = $button.parent();
    var txt = $button.attr("input");
    if ($button.attr('value') == 'show') {
        $button.attr('value', 'hide');
        $parent.next().removeAttr("hidden");
        $button.text("Hide Content");
    } else {
        $button.attr('value', 'show');
        $parent.next().attr("hidden", "");
        $button.text("Show Content");
    }
}
</script>

<!-- Print / Printing / printme -->
<!-- <script type="text/javascript">
i = 0

for (var i = 1; i < 6; i++) {
    var bodyContents = $(".bodyContents" + i);
    $("<p>").addClass("TOC1ul")  .appendTo(".TOC1");
    bodyContents.each(function(index, element) {
        var paragraph = $(element);
        $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC1ul");
         });
} 
</script>
 -->
 
</html>

