<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta charset="UTF-8">
  <title>Ahmad Badary</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/cayman.css">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="shortcut icon" href="/main_files/favicon.ico" />
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="/css/customStyle.css">
  <title> » Ahmad Badary</title>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
</head>

  <body>
    <nav class="main-nav">
    <a href="https://ahmedbadary.github.io/" class="main-nav-logo">
        <img src="/main_files/logo.png">
    </a>
    <ul id="menu-main" class="main-nav-items">
        <li id="menu-item-1859" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-home menu-item-1859">
            <a href="/">Home</a>
        </li>
        <li id="menu-item-2869" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2869">
            <a href="/work">Work</a>
        </li>
        <li id="menu-item-1892" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-1892">
            <a href="/projects">Projects</a>
        </li>
        <li id="menu-item-1858" class="menu-item menu-item-type-post_type menu-item-object-page current_page_parent menu-item-1858">
            <a href="/blog">Blog</a>
        </li>
        <li id="menu-item-1862" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-1862">
            <a href="/about">About</a>
        </li>
    </ul>
</nav>


<section class="page-header">
  <h1 class="project-name">Regularization</h1>
  <h2 class="project-tagline"></h2>
  <a href="/#" class="btn">Home</a>
  <a href="/work" class="btn">Work-Space</a>
  <a href= /work_files/research/dl/theory.html class="btn">Previous</a>
</section>

<!-- <div>
  <ul class="posts">
    
      <li><span>02 Jan 2014</span> &raquo; <a href="/2014/01/02/introducing-Ahmad/">Introducing Ahmad</a></li>
    
  </ul>
</div> -->


    <section class="main-content">
      
      <div class="TOC">
  <h1 id="table-of-contents">Table of Contents</h1>

  <ul class="TOC1">
    <li><a href="#content1">Regularization Basics and Definitions</a></li>
  </ul>
  <ul class="TOC2">
    <li><a href="#content2">Parameter Norm Penalties</a></li>
  </ul>
  <ul class="TOC3">
    <li><a href="#content3">Advanced Regularization Techniques</a></li>
  </ul>
</div>

<hr />
<hr />

<p id="lst-p"><strong style="color: red">Resources:</strong></p>
<ul>
  <li><a href="/work_files/research/dl/theory/dl_book_pt1#bodyContents133">Regularization in FFN</a></li>
  <li><a href="/concepts_#bodyContents616">Regularization Concept</a></li>
  <li><a href="https://medium.com/inveterate-learner/deep-learning-book-chapter-7-regularization-for-deep-learning-937ff261875c">Regularization Ch.7 Summary</a></li>
  <li><a href="http://cs229.stanford.edu/notes-spring2019/addendum_bias_variance.pdf">How Regularization Reduces Variance from bias-var-decomp</a></li>
  <li><a href="http://bjlkeng.github.io/posts/probabilistic-interpretation-of-regularization">Probabilistic Interpretation of Regularization (MAP)</a></li>
  <li><a href="https://www.wikiwand.com/en/Regularization_(mathematics)">The Math of Regularization</a></li>
  <li><a href="https://people.eecs.berkeley.edu/~bartlett/courses/281b-sp08/20.pdf">Regularization from excess risk</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Bayesian_interpretation_of_kernel_regularization">Bayesian Interpretation of Regularization (wikipedia)</a></li>
  <li><a href="http://www.isikdogan.com/blog/regularization.html">Regularization Methods Papers Explained</a></li>
  <li><a href="https://srdas.github.io/DLBook/ImprovingModelGeneralization.html">Improving Model Generalization (book)</a></li>
  <li><a href="https://web.stanford.edu/~hastie/Papers/ESLII.pdf#page=186">Regularization and Reproducing Kernel Hilbert Spaces (ESL)</a></li>
</ul>

<h2 id="content1">Regularization Basics and Definitions</h2>

<ol>
  <li>
    <p><strong style="color: SteelBlue" class="bodyContents1" id="bodyContents11">Regularization:</strong>  <br />
 <strong>Regularization</strong> can be, loosely, defined as: any modification we make to a learning algorithm that is intended to <em>reduce</em> its <em>generalization error</em> but not its <em>training error</em>.</p>

    <p>Formally, it is a set of techniques that impose certain restrictions on the hypothesis space (by adding information) in order to solve an <strong>ill-posed</strong> problem or to prevent <strong>overfitting</strong>.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup><br />
 <br /></p>
  </li>
  <li>
    <p><strong style="color: SteelBlue" class="bodyContents1" id="bodyContents12">Theoretical Justification for Regularization:</strong>  <br />
 A theoretical justification for regularization is that it attempts to impose Occam’s razor on the solution.<br />
 From a Bayesian point of view, many regularization techniques correspond to imposing certain prior distributions on model parameters.</p>

    <p id="lst-p"><strong style="color: red">Regularization from the NFL Theorem(s):</strong></p>
    <ul>
      <li>The <strong>No Free Lunch Theorem</strong>:<br />
  The following statement is <strong>FALSE</strong>:<br />
  <span style="color: purple">“Given a number of points (and a confidence), we can always achieve a prescribed error.”</span></li>
      <li><strong>Interpretation:</strong> inference from finite samples can be effectively performed if and only if the problem satisfies some a priori condition.</li>
      <li><strong>Implications</strong>:
        <ul>
          <li>This implies that there is no silver bullet: we shouldn’t expect any single optimization method to be perfect for all problems. Rather, we should try to design optimization methods that are tailored to the problem we’re trying to solve.<br />
  e.g. if you want to use local search, you’ll probably need to define a neighborhood relation that is informed by the problem domain.</li>
          <li>A practical implication is that machine learning won’t work if there is no structure at all on the space of possible models/hypotheses.<br />
  Instead, we need some kind of prior that makes some models more likely than others.</li>
        </ul>
      </li>
      <li><strong>Implying Regularization</strong>:<br />
  One of the most used <strong>priors</strong> is <strong style="color: goldenrod">Occam’s Razor</strong> which assumes that “simpler” models are more likely than complex one’s.<br />
  This leads to use of regularization in machine learning, as it effectively applies Occam’s razor to candidate models.<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">2</a></sup></li>
      <li><strong>Summary:</strong> NFL Theorem shows that regularization strategies are <em>necessary</em> to obtain <span style="color: purple">good generalization</span>.</li>
      <li><a href="https://cs.stackexchange.com/questions/88192/are-the-no-free-lunch-theorems-useful-for-anything">Ref</a></li>
    </ul>

    <p id="lst-p"><strong style="color: red">Notes:</strong></p>
    <ul>
      <li>Regularization emerges in a probabilistic (Bayesian) framework, where regularization can be performed by selecting a larger prior probability over simpler models; but also in statistical learning theory, where the goal is to minimize over two quantities: the ‘empirical risk’ and the ‘structural risk’, which roughly corresponds to the error over the training set and the predicted error in unseen data due to overfitting. - <a href="https://en.wikipedia.org/wiki/Artificial_neural_network#Generalization_and_statistics">wikipedia</a>
 <br /></li>
    </ul>
  </li>
  <li>
    <p><strong style="color: SteelBlue" class="bodyContents1" id="bodyContents13">Regularization in Deep Learning:</strong><br />
 In the context of DL, most regularization strategies are based on <strong>regularizing estimators</strong>, which usually works by <em>trading increased bias for reduced variance</em>.</p>

    <p>An effective regularizer is one that makes a profitable trade, reducing variance significantly while not overly increasing the bias.
 <br /></p>
  </li>
  <li>
    <p><strong style="color: SteelBlue" class="bodyContents1" id="bodyContents14">Regularization and Data Domains in DL - A Practical Motivation:</strong><br />
 Most applications of DL are to domains where the true data-generating process is almost certainly outside the model family (hypothesis space). Deep learning algorithms are typically applied to extremely complicated domains such as images, audio sequences and text, for which the true generation process essentially involves simulating the entire universe.</p>

    <p>Thus, controlling the complexity of the model is not a simple matter of finding the model of the right size, with the right number of parameters; instead, the best fitting model (wrt. generalization error) is a large model that has been regularized appropriately.</p>
  </li>
</ol>

<hr />

<h2 id="content2">Parameter Norm Penalties</h2>

<ol>
  <li><strong style="color: SteelBlue" class="bodyContents2" id="bodyContents21">Parameter Norms:</strong><br />
 Many regularization approaches are based on limiting the capacity of models by adding a parameter norm penalty \(\Omega(\boldsymbol{\theta})\) to the objective function \(J\). We denote the regularized objective function by \(\tilde{J}\):
    <p>$$\tilde{J}(\boldsymbol{\theta} ; \boldsymbol{X}, \boldsymbol{y})=J(\boldsymbol{\theta} ; \boldsymbol{X}, \boldsymbol{y})+\alpha \Omega(\boldsymbol{\theta}) \tag{7.1}$$</p>
    <p>where \(\alpha \in[0, \infty)\) is a HP that weights the relative contribution of the norm penalty term, \(\Omega\), relative to the standard objective function \(J\).</p>
    <ul>
      <li><strong>Effects of \(\alpha\)</strong>:
        <ul>
          <li>\(\alpha = 0\) results in NO regularization</li>
          <li>Larger values of \(\alpha\) correspond to MORE regularization</li>
        </ul>
      </li>
    </ul>

    <p>The <strong>effect of minimizing the regularized objective function</strong> is that it will <em><strong>decrease</strong></em>, both, <em>the original objective \(J\)</em> on the training data and some <em>measure of the size of the parameters \(\boldsymbol{\theta}\)</em>.</p>

    <p>Different choices for the parameter norm \(\Omega\) can result in different solutions being preferred.<br />
 <br /></p>
  </li>
  <li>
    <p><strong style="color: SteelBlue" class="bodyContents2" id="bodyContents22">Parameter Penalties and the Bias parameter:</strong><br />
 In NN, we usually penalize <strong>only the weights</strong> of the affine transformation at each layer and we leave the <strong>biases unregularized</strong>.<br />
 Biases typically require less data than the weights to fit accurately. The reason is that <em>each weight specifies how TWO variables interact</em> so fitting the weights well, requires observing both variables in a variety of conditions. However, <em>each bias controls only a single variable</em>, thus, we don’t induce too much <em>variance</em> by leaving the biases unregularized. If anything, regularizing the bias can introduce a significant amount of <em>underfitting</em>.<br />
 <br /></p>
  </li>
  <li>
    <p><strong style="color: SteelBlue" class="bodyContents2" id="bodyContents23">Note on the \(\alpha\) parameter for different hidden layers:</strong><br />
 In the context of neural networks, it is sometimes desirable to use a separate penalty with a different \(\alpha\) coefficient for each layer of the network. Because it can be expensive to search for the correct value of multiple hyperparameters, it is still reasonable to use the same weight decay at all layers just to reduce the size of search space.<br />
 <br /></p>
  </li>
  <li><strong style="color: SteelBlue" class="bodyContents2" id="bodyContents24">\(L^2\) Parameter Regularization (Weight Decay):</strong><br />
 It is a regularization strategy that <em>drives the weights closer to the origin</em><sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">3</a></sup> by adding a regularization term:
    <p>$$\Omega(\mathbf{\theta}) = \frac{1}{2}\|\boldsymbol{w}\|_ {2}^{2}$$</p>
    <p>to the objective function.</p>

    <p>In statistics, \(L^2\) regularization is also known as <strong>Ridge Regression</strong> or <strong>Tikhonov Regularization</strong>.</p>

    <p><strong style="color: red">Analyzing Weight Decay:</strong><br />
 <button class="showText" value="show" onclick="showText_withParent_PopHide(event);">Show Analysis</button></p>
    <ul hidden="">
      <li><strong>What happens in a Single Step</strong>:<br />
  We can gain some insight into the behavior of weight decay regularization by studying the gradient of the regularized objective function.<br />
  Take the models objective function:
        <p>$$\tilde{J}(\boldsymbol{w} ; \boldsymbol{X}, \boldsymbol{y})=\frac{\alpha}{2} \boldsymbol{w}^{\top} \boldsymbol{w}+J(\boldsymbol{w} ; \boldsymbol{X}, \boldsymbol{y}) \tag{7.2}$$</p>
        <p>with the corresponding <em>parameter gradient</em>:</p>
        <p>$$\nabla_{\boldsymbol{w}} \tilde{J}(\boldsymbol{w} ; \boldsymbol{X}, \boldsymbol{y})=\alpha \boldsymbol{w}+\nabla_{\boldsymbol{w}} J(\boldsymbol{w} ; \boldsymbol{X}, \boldsymbol{y}) \tag{7.3}$$</p>
        <p>The gradient descent update:</p>
        <p>$$\boldsymbol{w} \leftarrow \boldsymbol{w}-\epsilon\left(\alpha \boldsymbol{w}+\nabla_{\boldsymbol{w}} J(\boldsymbol{w} ; \boldsymbol{X}, \boldsymbol{y})\right) \tag{7.4}$$</p>
        <p>Equivalently:</p>
        <p>$$\boldsymbol{w} \leftarrow(1-\epsilon \alpha) \boldsymbol{w}-\epsilon \nabla_{\boldsymbol{w}} J(\boldsymbol{w} ; \boldsymbol{X}, \boldsymbol{y}) \tag{7.5}$$</p>

        <p>Observe that the addition of the weight decay term has modified the learning rule to <strong>multiplicatively shrink the weight vector by  a constant factor on each step</strong>, just before performing the usual gradient update.</p>
      </li>
      <li><strong>What happens over the Entire course of training</strong>:<br />
  We simplify the analysis by making a quadratic (2nd-order Taylor) approximation to the objective function in the neighborhood of the optimal wight-parameter of the unregularized objective \(\mathbf{w}^{\ast} = \arg \min_{\boldsymbol{w}} J(\boldsymbol{w})\).<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">4</a></sup><br />
  The approximation \(\hat{J}\):
        <p>$$\hat{J}(\boldsymbol{\theta})=J\left(\boldsymbol{w}^{\ast}\right)+\frac{1}{2}\left(\boldsymbol{w}-\boldsymbol{w}^{\ast}\right)^{\top} \boldsymbol{H}(J(\boldsymbol{w}^{\ast}))\left(\boldsymbol{w}-\boldsymbol{w}^{\ast}\right)  \tag{7.6}$$</p>
        <p>where \(\boldsymbol{H}\) is the Hessian matrix of \(J\) with respect to \(\mathbf{w}\) evaluated at \(\mathbf{w}^{\ast}\).</p>

        <p><strong>Notice:</strong></p>
        <ul>
          <li>There is no first-order term in this quadratic approximation, because \(\boldsymbol{w}^{\ast}\)  is defined to be a minimum, where the gradient vanishes.</li>
          <li>Because \(\boldsymbol{w}^{\ast}\) is the location of a minimum of \(J\), we can conclude that \(\boldsymbol{H}\) is <strong>positive semidefinite</strong>.</li>
        </ul>

        <p>The <strong>gradient</strong> of \(\hat{J} + \Omega(\mathbf{\theta})\):</p>
        <p>$$\nabla_{\boldsymbol{w}} \hat{J}(\boldsymbol{w})=\boldsymbol{H}(J(\boldsymbol{w}^{\ast}))\left(\tilde{\boldsymbol{w}}-\boldsymbol{w}^{\ast}\right) + \alpha \tilde{\boldsymbol{w}} \tag{7.7}$$</p>
        <p>And the <strong>minimum</strong> is achieved at \(\nabla_{\boldsymbol{w}} \hat{J}(\boldsymbol{w}) = 0\):</p>
        <p>$$\tilde{\boldsymbol{w}}=(\boldsymbol{H}+\alpha \boldsymbol{I})^{-1} \boldsymbol{H} \boldsymbol{w}^{\ast} \tag{7.10}$$</p>

        <p><strong>Effects:</strong></p>
        <ul>
          <li>As \(\alpha\) approaches \(0\): the regularized solution \(\tilde{\boldsymbol{w}}\) approaches \(\boldsymbol{w}^{\ast}\).</li>
          <li>As \(\alpha\) grows: we apply <strong>spectral decomposition</strong> to the <strong>real and symmetric</strong> \(\boldsymbol{H} = \boldsymbol{Q} \boldsymbol{\Lambda} \boldsymbol{Q}^{\top}\):
            <p>$$\begin{aligned} \tilde{\boldsymbol{w}} &amp;=\left(\boldsymbol{Q} \mathbf{\Lambda} \boldsymbol{Q}^{\top}+\alpha \boldsymbol{I}\right)^{-1} \boldsymbol{Q} \boldsymbol{\Lambda} \boldsymbol{Q}^{\top} \boldsymbol{w}^{\ast} \\ &amp;=\left[\boldsymbol{Q}(\boldsymbol{\Lambda}+\alpha \boldsymbol{I}) \boldsymbol{Q}^{\top}\right]^{-1} \boldsymbol{Q} \boldsymbol{\Lambda} \boldsymbol{Q}^{\top} \boldsymbol{w}^{\ast} \\ &amp;=\boldsymbol{Q}(\boldsymbol{\Lambda}+\alpha \boldsymbol{I})^{-1} \boldsymbol{\Lambda} \boldsymbol{Q}^{\top} \boldsymbol{w}^{\ast} \end{aligned} \tag{7.13}$$</p>
          </li>
        </ul>

        <p>Thus, we see that the effect of weight decay is to rescale \(\boldsymbol{w}^{\ast}\) along the axes defined by the eigenvector of \(\boldsymbol{H}\). Specifically, the component of \(\boldsymbol{w}^{\ast}\) that is aligned with the \(i\)-th eigenvector of \(\boldsymbol{H}\)  is rescaled by a factor of \(\frac{\lambda_{i}}{\lambda_{i}+\alpha}\).</p>

        <p><img src="/main_files/dl_book/regularization/1.png" alt="img" width="100%" /></p>

        <p><strong>Summary:</strong></p>

        <table>
          <tbody>
            <tr>
              <td><strong>Condition</strong></td>
              <td><strong>Effect of Regularization</strong></td>
            </tr>
            <tr>
              <td>\(\lambda_{i}&gt;&gt;\alpha\)</td>
              <td>Not much</td>
            </tr>
            <tr>
              <td>\(\lambda_{i}&lt;&lt;\alpha\)</td>
              <td>The weight value almost shrunk to \(0\)</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li><strong>Applying \(L^2\) regularization to <em>Linear Regression</em> :</strong>
        <ul>
          <li><button class="showText" value="show" onclick="showTextPopHide(event);">Application to Linear Regression</button>
  <img src="/main_files/dl_book/regularization/2.png" alt="img" width="100%" hidden="" /></li>
        </ul>
      </li>
      <li><a href="https://himarora.github.io/regularization/understanding-the-mathematics-of-weight-decay/">Weight Decay Analysis (blog)</a></li>
    </ul>
    <p><br /></p>

    <p><strong style="color: red">\(L^2\) Regularization Derivation:</strong><br />
 \(L^2\) regularization is equivalent to <strong>MAP Bayesian inference with a Gaussian prior on the weights</strong>.</p>

    <p><strong>The MAP Estimate:</strong><br />
 <button class="showText" value="show" onclick="showText_withParent_PopHide(event);">Show MAP Estimate Derivation</button></p>
    <p hidden="">$$\begin{aligned} \hat{\theta}_ {\mathrm{MAP}} &amp;=\arg \max_{\theta} P(\theta \vert y) \\ &amp;=\arg \max_{\theta} \frac{P(y \vert \theta) P(\theta)}{P(y)} \\ &amp;=\arg \max_{\theta} P(y \vert \theta) P(\theta) \\ &amp;=\arg \max_{\theta} \log (P(y \vert \theta) P(\theta)) \\ &amp;=\arg \max_{\theta} \log P(y \vert \theta)+\log P(\theta) \end{aligned}$$</p>

    <p>We place a <strong>Gaussian Prior</strong> on the weights, with <strong>zero mean</strong> and <strong>equal variance \(\tau^2\)</strong>:</p>
    <p>$$\begin{aligned} \hat{\theta}_ {\mathrm{MAP}} &amp;=\arg \max_{\theta} \log P(y \vert \theta)+\log P(\theta) \\ &amp;=\arg \max _{\boldsymbol{w}}\left[\log \prod_{i=1}^{n} \dfrac{1}{\sigma \sqrt{2 \pi}} e^{-\dfrac{\left(y_{i}-\boldsymbol{w}^{\top}\boldsymbol{x}_i\right)^{2}}{2 \sigma^{2}}}+\log \prod_{j=0}^{p} \dfrac{1}{\tau \sqrt{2 \pi}} e^{-\dfrac{w_{j}^{2}}{2 \tau^{2}}} \right] \\ &amp;=\arg \max _{\boldsymbol{w}} \left[-\sum_{i=1}^{n} \dfrac{\left(y_{i}-\boldsymbol{w}^{\top}\boldsymbol{x}_i\right)^{2}}{2 \sigma^{2}}-\sum_{j=0}^{p} \dfrac{w_{j}^{2}}{2 \tau^{2}}\right] \\ &amp;=\arg \min_{\boldsymbol{w}} \dfrac{1}{2 \sigma^{2}}\left[\sum_{i=1}^{n}\left(y_{i}-\boldsymbol{w}^{\top}\boldsymbol{x}_i\right)^{2}+\dfrac{\sigma^{2}}{\tau^{2}} \sum_{j=0}^{p} w_{j}^{2}\right] \\ &amp;=\arg \min_{\boldsymbol{w}} \left[\sum_{i=1}^{n}\left(y_{i}-\boldsymbol{w}^{\top}\boldsymbol{x}_i\right)^{2}+\lambda \sum_{j=0}^{p} w_{j}^{2}\right] \\ &amp;= \arg \min_{\boldsymbol{w}} \left[ \|XW - \boldsymbol{y}\|^2 + \lambda {\|\boldsymbol{w}\|_ 2}^2\right]\end{aligned}$$</p>
    <p><button class="showText" value="show" onclick="showTextPopHide(event);">Different Notation</button>
 <img src="/main_files/dl_book/regularization/4.png" alt="img" width="100%" hidden="" /> <br />
 <br /></p>

    <p id="lst-p"><strong style="color: red">Properties:</strong></p>
    <ul>
      <li>Notice that L2-regularization has a rotational invariance. This actually makes it more sensitive to irrelevant features.  <a href="https://www.cs.ubc.ca/~schmidtm/Courses/540-W18/L6.pdf">[Ref]</a>
        <blockquote>
          <p><a href="https://icml.cc/Conferences/2004/proceedings/papers/354.pdf">Paper</a></p>
        </blockquote>
      </li>
      <li>Adding L2-regularization to a convex function gives a strongly-convex function. So L2-regularization can make gradient descent converge much faster.  (^ same ref)</li>
    </ul>

    <p id="lst-p"><strong style="color: red">Notes:</strong></p>
    <ul>
      <li><a href="https://thomas-tanay.github.io/post--L2-regularization/">L2-reg and Adversarial Examples (New Angle)</a></li>
      <li><a href="https://himarora.github.io/regularization/understanding-the-mathematics-of-weight-decay/">Weight Decay Analysis (blog)</a></li>
      <li><strong>Interpreting the Penalty term \(\lambda\):</strong><br />
  In the Bayesian Interpretation of Weight Decay; by assuming a <strong>Gaussian Distribution</strong> on the errors:<br />
  the Penalty term \(\lambda\) can be interpreted as the (squared) <span style="color: purple">ratio of two <strong>variances</strong></span> of the <strong>data</strong> and the <strong>weights</strong> respectively: \(\lambda = \frac{\sigma_{D}^{2}}{\sigma_{W}^{2}}\).
        <ul>
          <li><a href="https://www.youtube.com/watch?v=_WZAD2uhvUM&amp;list=PLiPvV5TNogxKKwvKb1RKwkq2hm7ZvpHz0&amp;index=60">Learning the <strong>VARIANCES</strong> of the distributions/Priors (Hinton!)</a></li>
        </ul>
      </li>
      <li><a href="https://explained.ai/regularization/index.html">A visual explanation for regularization of linear models (Blog)</a><br />
 <br /></li>
    </ul>
  </li>
  <li><strong style="color: SteelBlue" class="bodyContents2" id="bodyContents25">\(L^1\) Regularization:</strong><br />
 \(L^1\) Regularization is another way to regulate the model by <em>penalizing the size of its parameters</em>; the technique adds a regularization term:
    <p>$$\Omega(\boldsymbol{\theta})=\|\boldsymbol{w}\|_{1}=\sum_{i}\left|w_{i}\right| \tag{7.18}$$</p>
    <p>which is a sum of absolute values of the individual parameters.</p>

    <p>The regularized objective function is given by:</p>
    <p>$$\tilde{J}(\boldsymbol{w} ; \boldsymbol{X}, \boldsymbol{y})=\alpha\|\boldsymbol{w}\|_ {1}+J(\boldsymbol{w} ; \boldsymbol{X}, \boldsymbol{y}) \tag{7.19}$$</p>
    <p>with the corresponding (sub) gradient:</p>
    <p>$$\nabla_{\boldsymbol{w}} \tilde{J}(\boldsymbol{w} ; \boldsymbol{X}, \boldsymbol{y})=\alpha \operatorname{sign}(\boldsymbol{w})+\nabla_{\boldsymbol{w}} J(\boldsymbol{X}, \boldsymbol{y} ; \boldsymbol{w}) \tag{7.20}$$</p>

    <p>Notice that the regularization contribution to the gradient, <strong>no longer scales linearly with each \(w_i\)</strong>; instead it is a <strong>constant factor with a sign = \(\text{sign}(w_i)\)</strong>.</p>

    <p>[Analysis]</p>

    <p><strong>Sparsity of the \(L^1\) regularization:</strong><br />
 In comparison to \(L^2\), \(L^1\) regularization results in a solution that is more <strong>sparse</strong>.<br />
 The <em>sparsity property</em> has been used extensively as a <strong>feature selection</strong> mechanism.</p>
    <ul>
      <li><strong>LASSO</strong>: The Least Absolute Shrinkage and Selection Operator integrates an \(L^1\) penalty with a <em>linear model</em> and a <em>least-squares cost function</em>.<br />
  The \(L^1\) penalty causes a subset of the weights to become <strong>zero</strong>, suggesting that the corresponding features may safely be discarded.</li>
    </ul>

    <p><strong style="color: red">\(L^1\) Regularization Derivation:</strong><br />
 \(L^1\) regularization is equivalent to (the log-prior term in) <strong>MAP Bayesian inference with an isotropic Laplace distribution prior on the weights</strong>:</p>
    <p>$$\log p(\boldsymbol{w})=\sum_{i} \log \operatorname{Laplace}\left(w_{i} ; 0, \frac{1}{\alpha}\right)=-\alpha\|\boldsymbol{w}\|_ {1}+n \log \alpha-n \log 2 \tag{7.24}$$</p>
    <p>note that we can ignore the terms \(\log \alpha-\log 2\) because they do not depend on \(\boldsymbol{w}\).    <br />
 <button class="showText" value="show" onclick="showText_withParent_PopHide(event);">Derivation</button></p>
    <p hidden="">$$\begin{aligned} \hat{\theta}_ {\mathrm{MAP}} &amp;=\arg \max_{\theta} \log P(y \vert \theta)+\log P(\theta) \\  &amp;=\arg \max _{\boldsymbol{w}}\left[\log \prod_{i=1}^{n} \dfrac{1}{\sigma \sqrt{2 \pi}} e^{-\dfrac{\left(y_{i}-\boldsymbol{w}^{\top}\boldsymbol{x}_i\right)^{2}}{2 \sigma^{2}}}+\log \prod_{j=0}^{p} \dfrac{1}{2 b} e^{-\dfrac{\left|\theta_{j}\right|}{2 b}} \right] \\    &amp;=\arg \max _{\boldsymbol{w}} \left[-\sum_{i=1}^{n} \dfrac{\left(y_{i}-\boldsymbol{w}^{\top}\boldsymbol{x}_i\right)^{2}}{2 \sigma^{2}}-\sum_{j=0}^{p} \dfrac{\left|w_{j}\right|}{2 b}\right] \\    &amp;=\arg \min_{\boldsymbol{w}} \dfrac{1}{2 \sigma^{2}}\left[\sum_{i=1}^{n}\left(y_{i}-\boldsymbol{w}^{\top}\boldsymbol{x}_i\right)^{2}+\dfrac{\sigma^{2}}{b} \sum_{j=0}^{p}\left|w_{j}\right|\right] \\    &amp;=\arg \min_{\boldsymbol{w}} \left[\sum_{i=1}^{n}\left(y_{i}-\boldsymbol{w}^{\top}\boldsymbol{x}_i\right)^{2}+\lambda \sum_{j=0}^{p}\left|w_{j}\right|\right] \\    &amp;= \arg \min_{\boldsymbol{w}} \left[ \|XW - \boldsymbol{y}\|^2 + \lambda \|\boldsymbol{w}\|_ 1\right]\end{aligned}$$</p>

    <p id="lst-p"><strong style="color: red">Properties:</strong></p>
    <ul>
      <li>\(L^1\) regularization can occasionally produce non-unique solutions. A simple example is provided in the figure when the space of possible solutions lies on a 45 degree line. 
 <br /></li>
    </ul>
  </li>
  <li>
    <p><strong style="color: SteelBlue" class="bodyContents2" id="bodyContents26">\(L^1\) VS \(L^2\) Regularization:</strong></p>

    <ul>
      <li><strong>Feature Correlation and Sparsity</strong>:
        <ul>
          <li><strong>Identical features</strong>:
            <ul>
              <li>\(L^1\) regularization spreads weight arbitrarily (all weights same sign)</li>
              <li>\(L^2\) regularization spreads weight evenly</li>
            </ul>
          </li>
          <li><strong>Linearly related features</strong>:
            <ul>
              <li>\(L^1\) regularization chooses variable with larger scale, \(0\) weight to others</li>
              <li>\(L^2\) prefers variables with larger scale — spreads weight proportional to scale
                <blockquote>
                  <p><a href="https://www.youtube.com/watch?v=KIoz_aa1ed4&amp;list=PLnZuxOufsXnvftwTB1HL6mel1V32w0ThI&amp;index=7">Reference</a></p>
                </blockquote>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    <p><strong style="color: red">Interpreting Sparsity with an Example:</strong><br />
 Let’s imagine we are estimating two coefficients in a regression. In \(L^2\) regularization, the solution \(\boldsymbol{w} =(0,1)\) has the same weight as \(\boldsymbol{w}=(\frac{1}{\sqrt{2}}, \frac{1}{\sqrt{2}})\)  so they are both treated equally. In \(L^1\) regularization, the same two solutions favor the sparse one:</p>
    <p>$$\|(1,0)\|_{1}=1&lt;\left\|\left(\frac{1}{\sqrt{2}}, \frac{1}{\sqrt{2}}\right)\right\|_{1}=\sqrt{2}$$</p>
    <p>So \(L^2\) regularization doesn’t have any specific built in mechanisms to favor zeroed out coefficients, while \(L^1\) regularization actually favors these sparser solutions.</p>
    <blockquote>
      <p><a href="https://www.quora.com/What-is-the-difference-between-L1-and-L2-regularization-How-does-it-solve-the-problem-of-overfitting-Which-regularizer-to-use-and-when">Extensive Discussions on Sparsity (Quora)</a></p>
    </blockquote>

    <p><br /></p>
  </li>
</ol>

<p><strong style="color: red">Notes:</strong></p>
<ul>
  <li><strong>Elastic Net Regularization:</strong>
    <p>$$\Omega = \lambda\left(\alpha\|w\|_{1}+(1-\alpha)\|w\|_{2}^{2}\right), \alpha \in[0,1]$$</p>
    <ul>
      <li>Combines both \(L^1\) and \(L^2\)</li>
      <li>Used to <strong>produce sparse solutions</strong>, but to avoid the problem of \(L^1\) solutions being sometimes <strong>Non-Unique</strong>
        <ul>
          <li>The problem mainly arises with <strong>correlated features</strong></li>
        </ul>
      </li>
      <li>Elastic net regularization tends to have a grouping effect, where correlated input features are assigned equal weights.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="content3">Advanced Regularization Techniques</h2>

<ol>
  <li>
    <p><strong style="color: SteelBlue" class="bodyContents3" id="bodyContents31">Regularization and Under-Constrained Problems:</strong><br />
 In some cases, regularization is necessary for machine learning problems to be properly define.</p>

    <p>Many linear models (e.g. Linear Regression, PCA) depend on <strong>inverting \(\boldsymbol{X}^{\top}\boldsymbol{X}\)</strong>. This is not possible if \(\boldsymbol{X}^{\top}\boldsymbol{X}\) is singular. In this case, many forms of regularization correspond to solving inverting \(\boldsymbol{X}^{\top} \boldsymbol{X}+\alpha \boldsymbol{I}\) instead. This regularized matrix is <strong>guaranteed to be invertible</strong>.</p>
    <ul>
      <li>\(\boldsymbol{X}^{\top}\boldsymbol{X}\) can be singular if:
        <ul>
          <li>The data-generating function truly has no variance in some direction.</li>
          <li>No Variance is <em>observed</em> in some direction because there are fewer examples (rows of \(\boldsymbol{X}\)) than input features (columns).</li>
        </ul>
      </li>
    </ul>

    <p>Models with no closed-form solution can, also, be <em>underdetermined</em>:<br />
 Take <strong>logistic regression on a linearly separable dataset</strong>, if a weight vector \(\boldsymbol{w}\) is able to achieve perfect classification, then so does \(2\boldsymbol{w}\) but with even <strong>higher likelihood</strong>. Thus, an iterative optimization procedure (sgd) will continually increase the magnitude of \(\boldsymbol{w}\) and, in theory, will <strong>never halt</strong>.<br />
 We can use regularization to guarantee the convergence of iterative methods applied to underdetermined problems: e.g. <strong>weight decay</strong> will cause gradient descent to <em>quit increasing the magnitude of the weights when the <strong>slope of the likelihood is equal to the weight decay coefficient</strong></em>.</p>

    <p><strong>Linear Algebra Perspective:</strong><br />
 Given that the <strong>Moore-Penrose pseudoinverse</strong> \(\boldsymbol{X}^{+}\) of a matrix \(\boldsymbol{X}\) can solve underdetermined linear equations:</p>
    <p>$$\boldsymbol{X}^{+}=\lim_{\alpha \searrow 0}\left(\boldsymbol{X}^{\top} \boldsymbol{X}+\alpha \boldsymbol{I}\right)^{-1} \boldsymbol{X}^{\top} \tag{7.29}$$</p>
    <p>we can now recognize the equation as <strong>performing linear regression with weight-decay</strong>.<br />
 Specifically, \(7.29\) is the limit of eq \(7.17\) as the <em>regularization coefficient shrinks to zero</em>.</p>
    <p>$$\boldsymbol{w}=\left(\boldsymbol{X}^{\top} \boldsymbol{X}+\alpha \boldsymbol{I}\right)^{-1} \boldsymbol{X}^{\top} \boldsymbol{y} \tag{7.17}$$</p>
    <p>We can thus interpret the pseudoinverse as <strong>stabilizing underdetermined problems using regularization</strong>.</p>

    <p><strong style="color: red">The Pseudoinverse:</strong><br />
 When applied to <em>underdetermined systems w/ non-unique solutions</em>; It finds the <em>minimum norm solution</em> to a linear system.<br />
 This “OLS” solution implies that not all linear functions are the same for OLS. It restricts the space of all possible non-unique linear functions that satisfy the equation to a subset of minimal norm.<br />
 From <strong>SLT</strong> perspective, the pseudoinverse introduces <strong>bias</strong> towards certain solutions.<br />
 <br /></p>
  </li>
  <li><strong style="color: SteelBlue" class="bodyContents3" id="bodyContents32">Dataset Augmentation:</strong><br />
 Having more data is the most desirable thing to improving a machine learning model’s performance. In many cases, it is relatively easy to artificially generate data.
    <ul>
      <li><strong>Applications</strong>: for certain problems like <strong>classification</strong> this approach is readily usable. E.g. for a classification task, we require the model to be <em>invariant to certain types of transformations</em>, of which we can generate data by applying them on our current dataset.<br />
  The most successful application of data-augmentation has been in <strong>object recognition</strong>.</li>
      <li><strong>Non-Applicable</strong>: this approach is not applicable to many problems, especially those that require us to learn the true data-distribution first E.g. Density Estimation.</li>
    </ul>

    <p><strong style="color: red">Noise Injection as Data-Augmentation:</strong><br />
 Injecting noise in the <em>input</em> to a NN <em>(Siestma and Dow, 1991)</em> can also be seen as a form of data augmentation.</p>
    <ul>
      <li><strong>Motivation:</strong>
        <ul>
          <li>For many classification and (some) regression tasks: the task should be possible to solve even if small random noise is added to the input <a href="/work_files/research/dl/theory/dl_book_pt1#bodyContents32">(Local Constancy)</a></li>
          <li>Moreover, NNs prove not to be very robust to noise.</li>
        </ul>
      </li>
    </ul>

    <p><strong>Injecting Noise in the Hidden Units:</strong><br />
 It can be seen as doing data-augmentation at <em><strong>multiple levels of abstraction</strong></em>. This approach can be highly effective provided that the magnitude of the noise is carefully tuned <em>(Poole et al. 2014)</em>.</p>
    <blockquote>
      <p><strong>Dropout</strong> can be seen as a process of constructing new inputs by <em>multiplying</em> by noise.</p>
    </blockquote>

    <p><br /></p>
  </li>
  <li><strong style="color: SteelBlue" class="bodyContents3" id="bodyContents33">Noise Robustness:</strong><br />
 We can apply <strong>Noise Injection</strong> to different components of the model as a way to regularize the model:<br />
 <strong style="color: red">Injecting Noise in the Input Layer:</strong>
    <ul>
      <li><strong>Motivation</strong>:<br />
  We have motivated the injection of noise, to the inputs, as a dataset augmentation strategy.</li>
      <li><strong>Interpretation</strong>:<br />
  For some models, the addition of noise with infinitesimal variance at the input of the model is equivalent to <strong>imposing a penalty on the norm of the weights</strong> <em>(Bishop, 1995a,b)</em>.</li>
    </ul>

    <p id="lst-p"><strong style="color: red">Injecting Noise in the Hidden Layers:</strong></p>
    <ul>
      <li><strong>Motivation</strong>:<br />
  We can motivate it as a variation of data augmentation.</li>
      <li><strong>Interpretation</strong>:<br />
  It can be seen as doing <strong>data-augmentation</strong> at <em><strong>multiple levels of abstraction</strong></em>.</li>
      <li><strong>Applications</strong>:<br />
  The most successful application of this type of noise injection is <strong>Dropout</strong>.<br />
  It can be seen as a process of constructing new inputs by <em>multiplying</em> by noise.</li>
    </ul>

    <p id="lst-p"><strong style="color: red">Injecting Noise in the Weight Matrices:</strong></p>
    <ul>
      <li><strong>Interpretation</strong>:
        <ol>
          <li>It can be interpreted as a stochastic implementation of Bayesian inference over the weights.
            <ul>
              <li><strong>The Bayesian View</strong>:<br />
  The Bayesian treatment of learning would consider the model weights to be <em>uncertain and representable via a probability distribution that reflects this uncertainty</em>. Adding noise to the weights is a practical, stochastic way to reflect this uncertainty.</li>
            </ul>
          </li>
          <li>It can, also, be interpreted as equivalent a more traditional form of regularization, <em>encouraging stability of the function to be learned</em>.
            <ul>
              <li><button class="showText" value="show" onclick="showTextPopHide(event);">Analysis</button>
  <img src="/main_files/dl_book/regularization/3.png" alt="img" width="100%" hidden="" /></li>
            </ul>
          </li>
        </ol>
      </li>
      <li><strong>Applications</strong>:<br />
  This technique has been used primarily in the context of <strong>recurrent neural networks</strong> <em>(Jim et al., 1996; Graves, 2011)</em>.</li>
    </ul>

    <p id="lst-p"><strong style="color: red">Injecting Noise in the Output Layer:</strong></p>
    <ul>
      <li><strong>Motivation</strong>:
        <ul>
          <li>Most datasets have some number of mistakes in the \(y\) labels. It can be harmful to maximize \(\log p(y \vert \boldsymbol{x})\) when \(y\) is a mistake. One way to prevent this is to explicitly model the noise on the labels.<br />
  One can assume that for some small constant \(\epsilon\), the training set label \(y\) is correct with probability \(1-\epsilon\).<br />
  This assumption is easy to incorporate into the cost function analytically, rather than by explicitly drawing noise samples (e.g. <strong>label smoothing</strong>).</li>
          <li>MLE with a softmax classifier and hard targets may never converge - the softmax can never predict a probability of exactly \(0\) or \(1\), so it will continue to learn larger and larger weights, making more extreme predictions forever.{: #bodyContents33mle}</li>
        </ul>
      </li>
      <li><strong>Interpretation</strong>:<br />
  For some models, the addition of noise with infinitesimal variance at the input of the</li>
      <li><strong>Applications</strong>:<br />
  <strong>Label Smoothing</strong> regularizes a model based on a softmax with \(k\) output values by replacing the hard \(0\) and \(1\) classification targets with targets of \(\dfrac{\epsilon}{k-1}\) and \(1-\epsilon\), respectively.
        <ul>
          <li><a href="#bodyContents33mle"><strong>Applied to MLE problem:</strong></a> Label smoothing, compared to weight-decay, has the advantage of preventing the pursuit of hard probabilities without discouraging correct classification.</li>
          <li>Application in modern NN: <em>(Szegedy et al. 2015)</em></li>
        </ul>
      </li>
    </ul>

    <p id="lst-p"><strong style="color: red">Notes:</strong></p>
    <ul>
      <li><a href="https://www.youtube.com/watch?v=5Fveuxdg8rU&amp;list=PLiPvV5TNogxKKwvKb1RKwkq2hm7ZvpHz0&amp;index=57">Using Noise as a Regularizer (Hinton Lec!)</a><br />
 <br /></li>
    </ul>
  </li>
  <li>
    <p><strong style="color: SteelBlue" class="bodyContents3" id="bodyContents34">Semi-Supervised Learning:</strong><br />
 <strong>Semi-Supervised Learning</strong> is a class of ML tasks and techniques that makes use of both unlabeled examples from \(P(\mathbf{x})\) and labeled examples from \(P(\mathbf{x}, \mathbf{y})\) to estimate \(P(\mathbf{y} \vert \mathbf{x})\) or predict \(\mathbf{y}\) from \(\mathbf{x}\).</p>

    <p>In the context of Deep Learning, Semi-Supervised Learning usually refers to <em>learning a representation \(\boldsymbol{h}=f(\boldsymbol{x})\)</em>; the goal being to learn a representation such that <strong>examples from the same class have similar representations</strong>. <br />
 Usually, <strong>Unsupervised Learning</strong> provides us clues (e.g. clustering) that influence the representation of the data.</p>
    <blockquote>
      <p><strong>PCA</strong>, as a preprocessing step before applying a classifier, is a long-standing variant of this approach.</p>
    </blockquote>

    <p><strong>Approach:</strong><br />
 Instead of separating the supervised and unsupervised criteria, we can instead have a generative model of \(P(\mathbf{x})\) (or \(P(\mathbf{x}, \mathbf{y})\)) which shares parameters with a discriminative model \(P(\mathbf{y} \vert \mathbf{x})\).<br />
 The idea is to share the unsupervised/generative criterion with the supervised criterion to <em>express a prior belief that the structure of \(P(\mathbf{x})\) (or \(P(\mathbf{x}, \mathbf{y})\)) is connected to the structure of \(P(\mathbf{y} \vert \mathbf{x})\)</em>, which is captured by the <em>shared parameters</em>.<br />
 By controlling how much of the generative criterion is included in the total criterion, one can find a better trade-off than with a purely generative or a purely discriminative training criterion <em>(Lasserre et al., 2006; Larochelle and Bengio, 2008)</em>.</p>

    <p><br /></p>
  </li>
  <li>
    <p><strong style="color: SteelBlue" class="bodyContents3" id="bodyContents35">Multitask Learning:</strong><br />
 <strong>Multitask Learning</strong> is a way to improve generalization by pooling the examples (which can be seen as soft constraints imposed on the parameters) arising out of several tasks. In the same way that additional data put more pressure on the parameters of the model toward values that generalize well, when part of a model is shared across tasks, that part of the model is more constrained toward good values (assuming the sharing is justified), often yielding better generalization.</p>

    <p>Improved generalization due to improved statistical strength of the shared parameters (in proportion w/ increased # of examples). This happens only is some assumptions about the statistical relationship of the different tasks are valid; i.e. they share something.</p>

    <p>From the point of view of deep learning, the underlying prior belief is the following:<br />
 <span style="color: goldenrod">Among the factors that explain the variations observed in the data associated with the different tasks, some are shared across two or more tasks.</span></p>

    <p id="lst-p"><strong style="color: red">Types:</strong></p>
    <ul>
      <li><strong>Task-specific</strong>: These parameters benefit only from that particular task for generalization.<br />
  These are the <em><strong>later layers</strong></em> in the NN.</li>
      <li><strong>Generic, (shared across all tasks)</strong>: benefit from the pooled data of all the tasks.<br />
  These are the <em><strong>earlier layers</strong></em> in the NN.<br />
 <br /></li>
    </ul>
  </li>
  <li>
    <p><strong style="color: SteelBlue" class="bodyContents3" id="bodyContents36">Early Stopping:</strong><br />
 <strong>Early Stopping:</strong> is a regularization method that aims to obtain a model with better validation set error (\(\implies\) generalization) by saving the model parameters at every epoch and returning to the parameter setting at the point in time with the lowest validation set error.</p>

    <p><strong style="color: red">Premise of Early Stopping:</strong><br />
 For a model with high representational capacity, after a certain point of time during training, the training error continues to decrease but the validation error begins to increase (overfitting). In such a scenario, a better idea would be to return back to the point where the validation error was the least.<br />
 <img src="https://cdn.mathpix.com/snip/images/nP6B2kfVhfI_4XZH9mE7IZUJYysgSD7xJwCHWWI1Zd8.original.fullsize.png" alt="img" width="50%" class="center-image" /></p>

    <p id="lst-p"><strong style="color: red">Algorithm:</strong><br />
 Early stopping requires the use of a <strong>validation set</strong>. Thus, we are not using the entire dataset for training. Choosing the ideal number of steps before we stop training can be done with cross-validation. Then, to utilize the entire dataset, a second phase of training can be done where the complete training set is used. There are two choices here:</p>
    <ol>
      <li>Train from scratch for the same number of steps as in the Early Stopping case.</li>
      <li>Use the weights learned from the first phase of training and <em>continue training</em> using the complete data (not as well behaved).</li>
    </ol>

    <p><strong style="color: red">As Regularization:</strong><br />
 Early Stopping affects the optimization procedure by restricting it to a small volume of the parameter space, in the neighbourhood of the initial parameter value \(\boldsymbol{\theta}_ {O}\).<br />
 <img src="https://cdn.mathpix.com/snip/images/OV_Sn63r2qP3Ke35-9vIewoMdlOaLcm7OjmDy2k-awc.original.fullsize.png" alt="img" width="45%" class="center-image" />
 <img src="https://cdn.mathpix.com/snip/images/3GPG44-IDdIae6EJcN4XqM1xU8Tx3igHCBzrqbWFbJ4.original.fullsize.png" alt="img" width="48%" class="center-image" /><br />
 Let \(\tau\) be the number of optimization steps taken (\(\tau\) training iterations) with lr \(\epsilon\). The product \(\epsilon\tau\) can be seen as a <strong style="color: goldenrod">measure of effective capacity</strong>. Assuming the gradient is bounded, restricting both the number of iterations and the learning rate limits the volume of parameter space reachable from \(\boldsymbol{\theta}_ {O}\); thus, \(\epsilon\tau\) behaves as the reciprocal of the regularization coefficient for <strong>weight decay</strong>: \(\epsilon\tau \approx \dfrac{1}{\lambda}\) \(\implies\)  <br />
 The number of training iterations has a role <em>inversely proportional</em> to the <strong>weight decay</strong> coefficient:</p>
    <p>$$\tau \approx \dfrac{1}{\epsilon\lambda}$$</p>
    <ul>
      <li>When the number of iterations \(\tau\) is small \(\iff \lambda\) is large: Regularization is large and the capacity is small</li>
      <li>When the number of iterations \(\tau\) is large \(\iff \lambda\) is small: Regularization is small and the capacity is large<br />
 Parameter values corresponding to directions of significant curvature (of the objective function) are regularized less than directions of less curvature. Of course, in the context of early stopping, this really means that parameters that correspond to directions of significant curvature tend to learn early relative to parameters corresponding to directions of less curvature.</li>
    </ul>

    <p><strong>Equivalence to Weight Decay for Linear Models:</strong><br />
 To compare with classical \(L^{2}\) regularization, we examine a simple setting where the only parameters are linear weights \((\boldsymbol{\theta}=\boldsymbol{w})\). We can model the cost function \(J\) with a quadratic approximation in the neighborhood of the empirically optimal value of the weights \(\boldsymbol{w}^{ * }\):</p>
    <p>$$\hat{J}(\boldsymbol{\theta})=J\left(\boldsymbol{w}^{ * }\right)+\frac{1}{2}\left(\boldsymbol{w}-\boldsymbol{w}^{ * }\right)^{\top} \boldsymbol{H}\left(\boldsymbol{w}-\boldsymbol{w}^{ * }\right)$$</p>
    <p>where \(\boldsymbol{H}\) is the Hessian matrix of \(J\) with respect to \(\boldsymbol{w}\) evaluated at \(\boldsymbol{w}^{ * } .\) Given the assumption that \(\boldsymbol{w}^{ * }\) is a minimum of \(J(\boldsymbol{w}),\) we know that \(\boldsymbol{H}\) is positive semidefinite.</p>

    <p><button class="showText" value="show" onclick="showText_withParent_PopHide(event);">Derivation</button></p>

    <p hidden=""><img src="https://cdn.mathpix.com/snip/images/huUJWa3v29VPPcKVQ8YFGh87GqYWSGjlHXdJBHLLHKw.original.fullsize.png" alt="img" width="100%" /><br />
 <img src="https://cdn.mathpix.com/snip/images/PcTAhXy0F88H4S4L9wWe6TWynvWUd2Bqq9nig3sKujQ.original.fullsize.png" alt="img" width="100%" /></p>

    <p id="lst-p"><strong style="color: red">Properties:</strong></p>
    <ul>
      <li>Early stopping is an <strong>unobtrusive form of regularization</strong>, in that it requires almost no change in the underlying training procedure, the objective function, or the set of allowable parameter values:
        <ul>
          <li>This means that it is easy to use early stopping without damaging the learning dynamics. This is in contrast to weight decay, where one must be careful not to use too much weight decay and trap the network in a bad local minimum corresponding to a solution with pathologically small weights.</li>
        </ul>
      </li>
      <li>Early Stopping does not add any extra hyperparameters, making it easy to incorporate without the need for extra tuning.</li>
      <li>It <strong>reduces the computation cost of training</strong> by:
        <ol>
          <li>Lowering the number of training steps</li>
          <li>Regularizing the model without having to add additional penalty terms (computation of gradients of additional terms)</li>
        </ol>
      </li>
      <li>Early stopping may be used either alone or in conjunction with other regularization strategies. Even when using regularization strategies that modify the objective function to encourage better generalization, it is rare for the best generalization to occur at a local minimum of the training objective.</li>
      <li>It is a form of <strong>spectral regularization</strong></li>
      <li><a href="http://web.mit.edu/lrosasco/www/publications/earlystop.pdf">ON EARLY STOPPING IN GRADIENT DESCENT LEARNING (paper)</a></li>
    </ul>

    <p><strong style="color: red">Intuition:</strong><br />
 (1) One way to think of early stopping is as a very efficient <span style="color: goldenrod">hyperparameter selection</span> algorithm. In this view, the <em>number of training steps is just another hyperparameter</em>. We can see that this hyperparameter has a \(U\)-shaped validation set performance curve. Most hyperparameters that control model capacity have such a \(U\)-shaped validation set performance curve. In the case of early stopping, we are <span style="color: goldenrod">controlling the effective capacity of the model by determining how many steps it can take to fit the training set</span>.</p>

    <p>(2) Early stopping can be viewed as <span style="color: goldenrod">regularization in time</span>. Intuitively, a training procedure like gradient descent will tend to learn more and more complex functions as the number of iterations increases. By regularizing on time, the complexity of the model can be controlled, improving generalization.</p>

    <p>(3) With a bounded step size, the number of steps dictates the radius ball (around your initial point) of points that is reachable. By stopping early, you limit this radius. “Weight decay is equivalent to a Lagrangian relaxation of a constraint on the weight norm. Early stopping (by previous argument) gives you the same constraint (assuming you start from 0). If you don’t start from 0, you might be able to still use triangle inequality to prove it.”</p>

    <p id="lst-p"><strong style="color: red">Notes:</strong></p>
    <ul>
      <li><strong>Why small weights in NN lead to lower capacity:</strong><br />
  For <em>sigmoid activation</em>, when the weights are very small, every hidden unit is in its linear range.<br />
  So a net with a large layer of hidden units has no more capacity than a linear net in which inputs are directly connected to the outputs.<br />
  This implies that the effective number of parameters is \(N\) minus the number of hidden unit parameters.<br />
  Thus, we can think of Early Stopping as controlling the effective number of parameters in the model by allowing it to use more of them until it fits the right amount of patterns in the data. (hinton Lec 9a)</li>
      <li><a href="https://blog.ml.cmu.edu/2019/03/07/a-continuous-time-view-of-early-stopping-for-least-squares/">A Continuous-Time View of Early Stopping for Least Squares (or: How I Learned to Stop Worrying and Love Early Stopping) (blog!)</a></li>
      <li><a href="https://www.mitpressjournals.org/doi/abs/10.1162/089976699300016557">No Free Lunch for Early Stopping (paper)</a><br />
  Shows that with a uniform prior on models having the same training error, early stopping at some fixed training error above the training error minimum results in an increase in the expected generalization error.<br />
 <br /></li>
    </ul>
  </li>
  <li>
    <p><strong style="color: SteelBlue" class="bodyContents3" id="bodyContents37">Parameter Tying and Parameter Sharing:</strong><br />
 Unlike the the methods focused on bringing the weights to a fixed point, e.g. 0 in the case of norm penalty, there might be situations where we might have some prior knowledge on the kind of dependencies that the model should encode.</p>

    <p><strong style="color: red">Parameter Tying:</strong><br />
 If two tasks are similar enough (similar input/output distributions), we might want to have the parameters of both models be close to each other in value. We do this with <strong>Parameter Tying:</strong> to use regularization to have two sets of parameters close to each other.<br />
 One way to achieve that (in an application) is to regularize the parameters of one model (\(L^2\) norm), trained as a classifier in a supervised paradigm, to be close to the parameters of another model, trained in an unsupervised paradigm (to capture the distribution of the observed input data).<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup></p>

    <p><strong style="color: red">Parameter Sharing:</strong><br />
 The more popular way is <strong>Parameter Sharing:</strong> to use constraints, <span style="color: goldenrod">to force sets of parameters to be equal</span>.</p>

    <p>A significant advantage of parameter sharing over regularizing the parameters to be close (via a norm penalty) is that only a subset of the parameters (the unique set) needs to be stored in memory, e.g. in CNNs this can lead to significant reduction in the memory footprint of the model.</p>

    <p>Parameter sharing has enabled CNNs to dramatically lower the number of unique model parameters and to significantly increase network sizes without requiring a corresponding increase in training data.</p>

    <p><br /></p>
  </li>
  <li><strong style="color: SteelBlue" class="bodyContents3" id="bodyContents38">Sparse Representations:</strong><br />
 Another strategy is to place a <strong>penalty on the activations</strong> of the units in a neural network, encouraging their activations to be sparse. This indirectly imposes a complicated penalty on the model parameters.
    <blockquote>
      <p>Unlike Weight decay which acts by placing a penalty directly on the model parameters.</p>
    </blockquote>

    <p>\(L^1\) regularization induces <span style="color: goldenrod">sparse parametrization</span> i.e. sparse weights.<br />
 <strong>Representational sparsity</strong>, on the other hand, induces <span style="color: goldenrod">sparse</span> <strong style="color: goldenrod">representations</strong> i.e. describes a representation where many of the elements of the representation are zero (or close to zero).</p>

    <p>Norm penalty regularization of representations is performed by adding to the loss function $J$ a norm penalty on the representation. This penalty is denoted \(\Omega(\boldsymbol{h}) .\) As before, we denote the regularized loss function by \(\tilde{J}\):</p>
    <p>$$\tilde{J}(\boldsymbol{\theta} ; \boldsymbol{X}, \boldsymbol{y})=J(\boldsymbol{\theta} ; \boldsymbol{X}, \boldsymbol{y})+\alpha \Omega(\boldsymbol{h})$$</p>
    <p>where \(\alpha \in[0, \infty)\) weights the relative contribution of the norm penalty term, with larger values of \(\alpha\) corresponding to more regularization.</p>

    <p id="lst-p">The <strong>regularizer</strong> \(\Omega\):</p>
    <ul>
      <li>\(L^1\) norm can be used</li>
      <li>Penalty derived from a Student $t$ <em>prior</em> distribution on the representation</li>
      <li>KL-divergence penalties: especially useful for representations with elements constrained to lie on the unit interval<br />
 Other approaches obtain representational sparsity with a hard constraint on the activation values. For example, <strong>orthogonal matching pursuit (OMP)</strong> (Pati et al, 1993) encodes an input \(x\) with the representation \(h\) that solves the constrained optimization problem:</li>
    </ul>
    <p>$$\underset{\boldsymbol{h},\|\boldsymbol{h}\|_ {0}&lt; k}{\arg \min }\|\boldsymbol{x}-\boldsymbol{W} \boldsymbol{h}\|^{2}$$</p>
    <p>where \(\|\boldsymbol{h}\|_ {0}\) is the number of nonzero entries of \(\boldsymbol{h}\) . This problem can be solved efficiently when \(\boldsymbol{W}\) is constrained to be orthogonal. This method is often called <strong>OMP-\(k\)</strong>, with the value of \(k\) specified to indicate the number of nonzero features allowed. Coates and \(\mathrm{Ng}(2011)\) demonstrated that \(\mathrm{OMP}-1\) can be a very effective feature extractor for deep architectures.<br />
 <br /></p>
  </li>
  <li>
    <p><strong style="color: SteelBlue" class="bodyContents3" id="bodyContents39">Ensemble Learning:</strong><br />
 <strong>Ensemble Learning</strong> is a set of <strong>ensemble methods</strong> that use multiple learning algorithms, (models) and a strategy called <strong>model averaging</strong> to combine the outcomes of those model, to obtain better predictive performance.</p>

    <p><strong>Model averaging</strong> is an extremely powerful and reliable method for reducing generalization error.</p>

    <p><strong style="color: red">Motivation:</strong><br />
 The reason that model averaging works is that different models will usually not make all the same errors on the test set.<br />
 Consider for example a set of \(k\) regression models. Suppose that each model makes an error \(\epsilon_{i}\) on each example, with the errors drawn from a zero-mean multivariate normal distribution with variances \(\mathbb{E}\left[\epsilon_{i}^{2}\right]=v\) and covariances \(\mathbb{E}\left[\epsilon_{i} \epsilon_{j}\right]=c\). Then the error made by the average prediction of all the ensemble models is \(\frac{1}{k} \sum_{i} \epsilon_{i}\). The expected squared error of the ensemble predictor is:</p>
    <p>$$\begin{aligned} \mathbb{E}\left[\left(\frac{1}{k} \sum_{i} \epsilon_{i}\right)^{2}\right] &amp;=\frac{1}{k^{2}} \mathbb{E}\left[\sum_{i}\left(\epsilon_{i}^{2}+\sum_{j \neq i} \epsilon_{i} \epsilon_{j}\right)\right] \\ &amp;=\frac{1}{k} v+\frac{k-1}{k} c \end{aligned}$$</p>
    <ul>
      <li>When the errors are <em><strong>perfectly correlated \(c=v\)</strong></em>: the MSE reduces to \(v\), so the model averaging does not help at all.</li>
      <li>When the errors are <em><strong>perfectly uncorrelated \(c=0\)</strong></em>, the expected squared error of the ensemble is only \(\dfrac{1}{k} v\).<br />
  Thus, the <span style="color: goldenrod">expected squared error of the ensemble is inversely proportional to the ensemble size</span>.<br />
 In other words, on average, the ensemble will perform at least as well as any of its members, and if the members make independent errors, the ensemble will perform significantly better than its members.</li>
    </ul>

    <p><strong style="color: red">As Regularization:</strong><br />
 Regularization has two general definitions:<br />
 (1) Any modification we make to a learning algorithm that is intended to <span style="color: goldenrod"><em>reduce</em> its <em>generalization error</em></span> but <span style="color: goldenrod">not its <em>training error</em></span>.<br />
 (2) Regularization is a (more general) way of <strong>controlling a models capacity</strong> by <span style="color: goldenrod">allowing us to express preference for one function over another in the same hypothesis space</span>; instead of including or excluding members from the hypothesis space completely.</p>

    <p>From those perspectives, the analysis (motivation) above shows that <strong>ensemble methods</strong> satisfy both criteria in gold.</p>

    <p><strong style="color: red">Bagging:</strong><br />
 <strong>Bagging</strong> is an ensemble method that aims to reduce the generalization error.<br />
 It reduces <strong>variance</strong> which corresponds to <strong>generalization error</strong>, thus decreasing <strong>capacity</strong>.</p>

    <p><strong style="color: red">Boosting:</strong><br />
 <em>Not all techniques for constructing ensembles are designed to make the ensemble more regularized than the individual models</em>. For example, a technique called <strong>boosting</strong> (Freund and Schapire, 1996b,a) constructs an ensemble with <em>higher capacity than the individual models</em>. <br />
 It reduces <strong>bias</strong> which corresponds to <strong>approximation error</strong>, thus increasing <strong>capacity</strong>.<br />
 <br /></p>
  </li>
  <li>
    <p><strong style="color: SteelBlue" class="bodyContents3" id="bodyContents310">Dropout:</strong><br />
<strong>Dropout</strong> <em>(Srivastava et al., 2014)</em> provides a computationally inexpensive but powerful method of regularizing a broad family of models.</p>

    <p><strong style="color: red">Dropout as (an approximation to) Bagging Ensemble Method for Neural Networks:</strong><br />
To a first approximation, dropout can be thought of as a method of making <strong>bagging</strong> practical for ensembles of very many large neural networks.<br />
Bagging involves training multiple models and evaluating multiple models on each test example. This seems impractical when each model is a large neural network, since training and evaluating such networks is costly in terms of runtime and memory. It is common to use ensembles of five to ten neural networks—Szegedy et al. (2014a) used six to win the ILSVRC— but more than this rapidly becomes unwieldy.<br />
Dropout provides an inexpensive approximation to training and evaluating a bagged ensemble of exponentially many neural networks. Specifically, dropout trains the ensemble consisting of all subnetworks that can be formed by removing nonoutput units from an underlying base network. In modern NNs, we can remove a unit by “multiplying” its output by zero.</p>

    <p>Recall that to learn with bagging, we define \(k\) different models, construct \(k\) different datasets by sampling from the training set with replacement, and then train model \(i\) on dataset \(i\). Dropout aims to approximate this process, but with an exponentially large number of neural networks.</p>

    <p id="lst-p"><strong>Dropout Algorithm:</strong><br />
To train with dropout, we:</p>
    <ul>
      <li>Use a minibatch-based learning algorithm that makes small steps, such as stochastic gradient descent.</li>
      <li>Each time we load an example into a minibatch, we randomly sample a different binary mask to apply to all the input and hidden units in the network.
        <ul>
          <li>The mask for each unit is sampled <strong>independently</strong> from all the others.</li>
          <li>The <strong>probability of sampling a mask value of one</strong> (causing a unit to be included) is a <em>hyperparameter</em> fixed before training begins. It is not a function of the current value of the model parameters or the input example.</li>
        </ul>
      </li>
      <li>Typically, an input unit is included with probability \(0.8\), and a hidden unit is included with probability \(0.5\).</li>
      <li>We then run forward propagation, back-propagation, and the learning update as usual.</li>
    </ul>

    <p><strong>Formally,</strong> suppose that a mask vector \(\mu\) specifies which units to include, and \(J(\boldsymbol{\theta}, \boldsymbol{\mu})\) defines the cost of the model defined by parameters \(\boldsymbol{\theta}\) and mask \(\boldsymbol{\mu}\) Then dropout training consists of minimizing \(\mathbb{E}_ {\boldsymbol{\mu}} J(\boldsymbol{\theta}, \boldsymbol{\mu})\). The expectation contains exponentially many terms, but we can obtain an unbiased estimate of its gradient by sampling values of \(\boldsymbol{\mu}\).</p>

    <p id="lst-p"><strong>Differences:</strong></p>
    <ul>
      <li><strong>Training (compare each number)</strong>:
        <ul>
          <li><strong>Bagging:</strong>
            <ol>
              <li>The models are all independent.</li>
              <li>Each model is trained to convergence on its respective training set.</li>
            </ol>
          </li>
          <li><strong>Dropout</strong>:
            <ol>
              <li>The models share parameters, with each model inheriting a different subset of parameters from the parent neural network.<br />
 This parameter sharing makes it possible to represent an exponential number of models with a tractable amount of memory.</li>
              <li>Most models are not explicitly trained at all—usually, the model is large enough that it would be <em>infeasible to sample all possible subnetworks</em> within the lifetime of the universe. Instead, a tiny fraction of the possible subnetworks are each trained for a single step, and the parameter sharing causes the remaining subnetworks to arrive at good settings of the parameters.</li>
            </ol>
          </li>
        </ul>

        <blockquote>
          <p>Beyond these difference, dropout follows the bagging algorithm; e.g. training set encountered by each subnetwork is indeed a subset of the original training set sampled with replacement.</p>
        </blockquote>
      </li>
      <li><strong>Inference (Prediction)</strong>:<br />
  So far, our description of bagging and dropout has not required that the model be explicitly probabilistic. Now, we <em>assume</em> that the model’s role is to <em>output a <strong>probability distribution</strong></em>.
        <ul>
          <li><strong>Bagging:</strong> Each model \(i\) produces a probability distribution \(p^{(i)}(y \vert \boldsymbol{x})\).<br />
  The prediction of the ensemble is given by the <strong>arithmetic mean</strong> of all these distributions:
            <p>$$\frac{1}{k} \sum_{i=1}^{k} p^{(i)}(y \vert \boldsymbol{x})$$</p>
          </li>
          <li><strong>Dropout</strong>: Each submodel defined by mask vector \(\boldsymbol{\mu}\) defines a probability distribution \(p(y \vert x, \mu)\).<br />
  The <strong>arithmetic mean</strong> over all masks is given by:
            <p>$$\sum_{\mu} p(\boldsymbol{\mu}) p(y \vert \boldsymbol{x}, \boldsymbol{\mu})$$</p>
            <p>where \(p(\boldsymbol{\mu})\) is the probability distribution that was used to sample \(\boldsymbol{\mu}\) at training time.</p>

            <ul>
              <li><strong>Issues with direct inference with the arithmetic mean</strong>:<br />
  Because this sum includes an exponential number of terms, it is intractable to evaluate except when the structure of the model permits some form of simplification.</li>
              <li><strong>Solution - Geometric Mean + Weight Scaling Inference</strong>:<br />
  The following approach allows us to obtain a good approximation to the predictions of the entire ensemble, at the cost of only one forward propagation.<br />
  The <strong>geometric mean</strong> of multiple probability distributions is <em>not guaranteed to be a probability distribution</em>. We guarantee it by imposing the requirement that <em>none of the submodels assigns probability \(0\) to any event</em>, and we <em>renormalize the resulting distribution</em>.<br />
  <strong>The <em>Unnormalized</em> distribution defined by the geometric mean:</strong>
                <p>$$\tilde{p}_{\text {ensemble }}(y \vert \boldsymbol{x})=2 \sqrt[2 d]{\prod_{\boldsymbol{\mu}} p(y \vert \boldsymbol{x}, \boldsymbol{\mu})}$$</p>
                <p>where \(d\) is the number of units that may be dropped<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">6</a></sup>.<br />
  <strong>The <em>Normalized</em> distribution:</strong></p>
                <p>$$p_{\text {ensemble }}(y \vert \boldsymbol{x})=\frac{\tilde{p}_{\text {ensemble }}(y \vert \boldsymbol{x})}{\sum_y \tilde{p}_{\text {ensemble }}\left(y^{\prime} \vert \boldsymbol{x}\right)}$$</p>

                <p><strong>Weight Scaling Inference Rule:</strong> that approximates \(p_{\text {ensemble}}\) by evaluating \(p(y \vert \boldsymbol{x})\) in one model: the model with all units, but with the weights going out of unit \(i\) multiplied by the probability of including unit \(i\).</p>

                <ul>
                  <li><strong>Analysis and Justification:</strong>
                    <ul>
                      <li><em>Warde-Farley et al. (2014)</em> present arguments and empirical evidence that the geometric mean performs comparably to the arithmetic mean in this context.</li>
                      <li>A key insight <em>(Hinton et al., 2012c)</em> involved in dropout is that we can approximate \(p_{\text {ensemble}}\) by evaluating \(p(y \vert \boldsymbol{x})\) in one model: the model with all units, but with the weights going out of unit \(i\) multiplied by the probability of including unit \(i\) - The <strong>Weight Scaling Inference Rule:</strong>. The <strong>motivation</strong> for this modification is to <em><strong>capture the right expected value of the output from that unit</strong></em>. <br />
  There is not yet any theoretical argument for the accuracy of this approximate inference rule in deep nonlinear networks, but empirically it performs very well.<br />
  The <strong>goal</strong> is to make sure that <span style="color: goldenrod">the expected total input to a unit at test time is roughly the same as the expected total input to that unit at train time</span>.<br />
  is a method that aims to make sure that <span style="color: goldenrod">the expected total input to a unit at test time is roughly the same as the expected total input to that unit at train time</span>.<br />
  For many classes of models that do not have nonlinear hidden units, the weight scaling inference rule is exact; e.g. softmax regression classifier <em>(proof page 260 dlbook)</em>.<br />
  The weight scaling rule is also exact in other settings, including <strong>regression networks with conditionally normal outputs</strong> as well as <strong>deep networks that have hidden layers without nonlinearities</strong>.<br />
  However, the weight scaling rule is only <strong>an approximation for deep models that have <em>nonlinearities</em></strong>. Though the approximation has not been theoretically characterized, it often works well, empirically.<br />
  <em>Goodfellow et al. (2013a)</em> found experimentally that the weight scaling approximation can work better (in terms of classification accuracy) than Monte Carlo approximations to the ensemble predictor. This held true even when the Monte Carlo approximation was allowed to sample up to 1,000 subnetworks. <em>Gal and Ghahramani (2015)</em> found that some models obtain better classification accuracy using twenty samples and the Monte Carlo approximation.<br />
  It appears that <span style="color: goldenrod">the optimal choice of inference approximation is problem dependent</span>.
                        <ul>
                          <li>One other, non-efficient, way to do inference is to approximate it with sampling by averaging together the output from many masks. Even 10–20 masks are often sufficient to obtain good performance.<br />
  Weight Scaling Rule is far superior.</li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    <p id="lst-p"><strong style="color: red">Properties and Advantages:</strong></p>
    <ul>
      <li>Srivastava et al. (2014) showed that dropout is more effective than other standard computationally inexpensive regularizers, such as weight decay, filter norm constraints, and sparse activity regularization.</li>
      <li>Dropout may be combined with other forms of regularization to yield a further improvement.</li>
      <li>Dropout is very computationally cheap.<br />
  Using it in training requires only \(\mathcal{O}(n)\) computation per example per update, to generate \(n\) random binary numbers and multiply them by the state.</li>
      <li>Dropout does not significantly limit the type of model or training procedure that can be used.<br />
  It works well with nearly any model that uses a distributed representation and can be trained with stochastic gradient descent; e.g. feedforward neural networks, probabilistic models such as restricted Boltzmann machines, and RNNs.</li>
      <li>Stochasticity is Neither <em>necessary</em> Nor <em>sufficient</em> for the regularization effects of dropout:
        <ul>
          <li>The stochasticity used while training with dropout is NOT necessary for the approaches success. It is just a means of approximating the sum over all submodels. <br />
  <strong>Fast Dropout</strong> is an analytical approximations to this marginalization.</li>
          <li>Applying the same stochastic masks in a method analogous to <strong>boosting</strong>, where the stochastically sampled ensemble members are not trained independently, show almost no regularization effect compared to when the ensemble members are trained to perform well independently of each other.<br />
  <strong>Dropout boosting</strong> is one method that trains the entire ensemble to jointly maximize the log-likelihood on the training set; and experiments have shown that it displays no regularization compared to training the entire network as a single model.</li>
        </ul>
      </li>
      <li>The sharing of the weights means that every model is very strongly regularized.<br />
  This regularization is much better than L2 or L1 penalties since instead of pulling the weights towards zero, we are pulling the weights towards the correct value of the weights.</li>
      <li><a href="https://www.youtube.com/watch?v=vAVOY8frLlQ&amp;t=0s">Dropout - Hinton</a></li>
      <li>Running the <strong>stochastic</strong> model several times on the same input (instead of all the weights halved), <span style="color: goldenrod">gives an idea of the uncertainty in the answer</span>.</li>
      <li>We can use dropout in the <strong>input layer</strong>, but with a higher probability of keeping an input unit:<br />
  <em><strong>Denoising Autoencoders</strong></em> use this.</li>
    </ul>

    <p id="lst-p"><strong style="color: red">Practical Disadvantages/Issues:</strong></p>
    <ul>
      <li>Typically the optimal validation set error is much lower when using dropout, but this comes at the cost of a much larger model and many more iterations of the training algorithm. For very large datasets, regularization confers little reduction in generalization error. In these cases, the computational cost of using dropout and larger models may outweigh the benefit of regularization.</li>
      <li>When extremely few labeled training examples are available, dropout is less effective. Bayesian neural networks (Neal, 1996) outperform dropout on the Alternative Splicing Dataset (Xiong et al., 2011), where fewer than 5,000 examples are available (Srivastava et al., 2014). When additional unlabeled data is available, unsupervised feature learning can gain an advantage over dropout.</li>
    </ul>

    <p id="lst-p"><strong style="color: red">Dropout as Regularization - Effectiveness of Dropout:</strong></p>
    <ul>
      <li>Dropout can be viewed as a means of performing <span style="color: goldenrod">efficient, approximate <strong>bagging</strong></span>.</li>
      <li>Dropout trains not just a bagged ensemble of models, but an <span style="color: goldenrod">ensemble of models that <strong>share hidden units</strong></span>.<br />
  This means each hidden unit must be able to perform well regardless of which other hidden units are in the model. Hidden units must be prepared to be swapped and interchanged between models.<br />
  Dropout, thus, <span style="color: goldenrod">regularizes each hidden unit to be not merely a good feature but a feature that is <strong>good in many contexts</strong></span>.<br />
  This <span style="color: goldenrod">prevents <em><strong>Co-Adaptation</strong></em> between hidden-units on the Training Data</span>.</li>
      <li>A large portion of the power of dropout arises from the fact that the <strong>masking noise is applied to the <em>hidden units</em></strong>. This can be seen as a form of <span style="color: goldenrod">highly intelligent, adaptive <strong>destruction of the information content</strong></span> of the input rather than destruction of the raw values of the input.<br />
  This views dropout as <strong>noise-injection</strong> in the <em>hidden units</em>. Which can be seen as doing <span style="color: goldenrod"><strong>data-augmentation</strong> at <em><strong>multiple levels of abstraction</strong></em></span>.<br />
  <button class="showText" value="show" onclick="showTextPopHide(event);">Analysis</button>
  <span hidden="">For example, if the model learns a hidden unit that detects a face by finding the \(h_i\) nose, then dropping corresponds to erasing the information that there is a nose \(h_i\) in the image. The model must learn another \(h_i\), that either redundantly encodes the presence of a nose or detects the face by another feature, such as the mouth. Traditional noise injection techniques that add unstructured noise at the input are not able to randomly erase the information about a nose from an image of a face unless the magnitude of the noise is so great that nearly all the information in the image is removed. Destroying extracted features rather than original values allows the destruction process to make use of all the knowledge about the input distribution that the model has acquired so far.</span></li>
      <li>When viewed as <strong>noise-injection</strong>, an important aspect of dropouts success is that it uses <span style="color: goldenrod">multiplicative noise</span>.<br />
  Multiplicative noise does not allow for <em>pathological solutions</em> to the noise robustness problem: If the noise were additive with fixed scale, then a rectified linear hidden unit \(h_{i}\) with added noise \(\epsilon\) could simply learn to have \(h_{i}\) become very large in order to make the added noise \(\epsilon\) insignificant by comparison.</li>
    </ul>

    <p><strong style="color: red">Dropout and Batch Normalization:</strong><br />
Another deep learning algorithm, <strong>batch normalization</strong>, reparametrizes the model in a way that introduces both <strong>additive</strong> and <strong>multiplicative noise</strong> on the <em>hidden units</em> at training time. The primary purpose of batch normalization is to improve optimization, but the noise can have a regularizing effect, and sometimes makes dropout unnecessary.</p>

    <p><strong style="color: red">Modifying Dropout and source of Regularization:</strong><br />
One of the key insights of dropout is that <span style="color: goldenrod">training a network with stochastic behavior and making predictions by averaging over multiple stochastic decisions implements a form of bagging with parameter sharing</span>.<br />
Earlier, we described dropout as bagging an ensemble of models formed by including or excluding units. Yet this model averaging strategy does not need to be based on inclusion and exclusion. In principle, any kind of random modification is admissible.<br />
In practice, we must choose modification families that:<br />
(1) neural networks are able to learn to resist.<br />
(2) Ideally, we should also use model families that allow a fast approximate inference rule.<br />
We can think of any form of modification parametrized by a vector \(\mu\) as training an ensemble consisting of \(p(y \vert \boldsymbol{x}, \boldsymbol{\mu})\) for all possible values of \(\boldsymbol{\mu}\) There is no requirement that \(\boldsymbol{\mu}\) have a finite number of values. For example, \(\boldsymbol{\mu}\) can be real valued. Srivastava et al. \((2014)\) showed that multiplying the weights by \(\boldsymbol{\mu} \sim \mathcal{N}(\mathbf{1}, I)\) can outperform dropout based on binary masks. Because \(\mathbb{E}[\boldsymbol{\mu}]=\mathbf{1}\), the standard network automatically implements approximate inference in the ensemble, without needing any weight scaling.</p>

    <p><strong style="color: red">Dropout as Weight Decay in linear models:</strong><br />
<em>Wager et al. (2013)</em> showed that, when applied to linear regression, dropout is equivalent to <strong>L2 weight decay</strong>, with a <strong>different weight decay coefficient for each input feature</strong>. The <strong>magnitude of each feature’s weight decay coefficient is determined by its variance</strong>. Similar results hold for other linear models.<br />
For deep models, dropout is NOT equivalent to weight decay.<br />
<br /></p>

    <p id="lst-p"><strong style="color: red">Notes:</strong></p>
    <ul>
      <li><a href="https://sebastianraschka.com/faq/docs/dropout-activation.html">When to use Dropout (before/after activation)? (blog)</a><br />
<br /></li>
    </ul>
  </li>
  <li>
    <p><strong style="color: SteelBlue" class="bodyContents3" id="bodyContents311">Adversarial Training:</strong><br />
<strong>Adversarial training</strong> refers to training on examples that are adversarially generated and it has been shown to reduce the error rate.</p>

    <p><strong>Adversarial Examples:</strong> are examples that are intentionally constructed by using an optimization procedure to search for an input \(\boldsymbol{x}^{\prime}\) near a data point \(\boldsymbol{x}\) such that the model output is very different at \(\boldsymbol{x}^{\prime} .\) In many cases, \(\boldsymbol{x}^{\prime}\) can be so similar to \(\boldsymbol{x}\) that a human observer cannot tell the difference between the original example and the adversarial example, but the network can make highly different predictions.<br />
<em>Szegedy et al. (2014b)</em> found that even neural networks that perform at human level accuracy have a nearly \(100\%\) error rate on <strong>adversarial examples</strong>.<br />
<img src="https://cdn.mathpix.com/snip/images/_TFBraSdZd9ZN5OC9dLMcF4oAZOmY2gY2_hVcnwVM5s.original.fullsize.png" alt="img" width="50%" /></p>

    <p><strong style="color: red">Application in Regularization:</strong><br />
<strong>Adversarial Examples</strong> are interesting in the context of regularization because one can <em>reduce the error rate on the original test set via <strong>adversarial training</strong></em>—training on adversarially perturbed examples from the training set (Szegedy et al., 2014b; Goodfellow et al., 2014b).<br />
<em>Goodfellow et al. (2014b)</em> showed that one of the primary causes of these adversarial examples is excessive linearity. Neural networks are built out of primarily linear building blocks. In some experiments the overall function they implement proves to be highly linear as a result. These linear functions are easy to optimize. Unfortunately, the value of a linear function can change very rapidly if it has numerous inputs. If we change each input by \(\epsilon\) , then a linear function with weights \(w\) can change by as much as \(\epsilon \|w\|_ 1\), which can be a very large amount if \(w\) is high-dimensional.<br />
Adversarial training <span style="color: goldenrod">discourages this highly sensitive locally linear behavior by encouraging the network to be locally constant in the neighborhood of the training data</span>. This can be seen as a way of <strong style="color: goldenrod">explicitly introducing a local constancy prior</strong> into supervised neural nets.</p>

    <p><strong>As Semi-supervised Learning:</strong><br />
<strong>Virtual Adversarial Examples</strong> are adversarial examples generated using not the true label but a label provided by a trained model <em>(Miyato et al., 2015)</em>.<br />
Using virtual examples, we can train a classifier to assign the same label to \(x\) and \(x^{\prime}\). This encourages the classifier to learn a function that is robust to small changes anywhere along the manifold where the unlabeled data lie. The assumption motivating this approach is that different classes usually lie on disconnected manifolds, and a small perturbation should not be able to jump from one class manifold to another class manifold.</p>
    <blockquote>
      <p>At a point \(\boldsymbol{x}\) that is not associated with a label in the dataset, the model itself assigns some label \(\hat{y}\) . The model’s label \(\hat{y}\) may not be the true label, but if the model is high quality, then \(\hat{y}\) has a high probability of providing the true label. We can seek an adversarial example \(\boldsymbol{x}^{\prime}\) that causes the classifier to output a label \(y^{\prime}\) with \(y^{\prime} \neq \hat{y}\).</p>
    </blockquote>

    <p><strong>Motivation:</strong><br />
The assumption motivating this approach is that <span style="color: goldenrod">different classes usually lie on disconnected manifolds</span>, and a small perturbation should not be able to jump from one class manifold to another class manifold.<br />
<br /></p>
  </li>
  <li>
    <p><strong style="color: SteelBlue" class="bodyContents3" id="bodyContents312">Tangent Distance, Tangent Prop and Manifold Tangent Classifiers:</strong><br />
<strong style="color: red">Tangent Distance Algorithm:</strong><br />
Many ML models assume the data to lie on a low dimensional manifold to overcome the curse of dimensionality. The inherent assumption which follows is that small perturbations that cause the data to move along the manifold (it originally belonged to), shouldn’t lead to different class predictions. The idea of the <strong>tangent distance</strong> algorithm to find the K-nearest neighbors using the distance metric as the distance between manifolds. A manifold \(M_i\) is approximated by the tangent plane at \(x_i\), hence, this technique needs tangent vectors to be specified.</p>

    <p><strong style="color: red">Tangent Prop Algorithm:</strong><br />
The <strong>tangent prop</strong> algorithm proposed to learn a neural network based classifier, \(f(x)\), which is invariant to known transformations causing the input to move along its manifold. Local invariance would require that \(\bigtriangledown_x f(x)\) is perpendicular to the tangent vectors \(V^{(i)}\). This can also be achieved by adding a penalty term that minimizes the directional directive of \(f(x)\) along each of the \(V(i)\):</p>
    <p>$$\Omega(f)=\sum_{i}\left(\left(\nabla_{\boldsymbol{x}} f(\boldsymbol{x})\right)^{\top} \boldsymbol{v}^{(i)}\right)^{2}$$</p>
    <p><strong>Tangent Propagation</strong> is similar to data augmentation in that both of them use prior knowledge of the domain to specify various transformations that the model should be invariant to. However, tangent prop only resists infinitesimal perturbations while data augmentation causes invariance to much larger perturbations.</p>

    <p><strong>Drawbacks:</strong><br />
While this analytical approach is intellectually elegant, it has two major drawbacks.</p>
    <ol>
      <li>It only regularizes the model to resist infinitesimal perturbation.<br />
 Explicit dataset augmentation confers resistance to larger perturbations.</li>
      <li>The infinitesimal approach poses difficulties for models based on rectified linear units.<br />
 These models can only shrink their derivatives by turning units off or shrinking their weights. They are not able to shrink their derivatives by saturating at a high value with large weights, as sigmoid or tanh units can.<br />
 Dataset augmentation works well with rectified linear units because different subsets of rectified units can activate for different transformed versions of each original input.</li>
    </ol>

    <p><strong style="color: red">Manifold Tangent Classifier:</strong><br />
The manifold tangent classifier (Rifai et al., 2011c), eliminates the need to know the tangent vectors a priori. Autoencoders can estimate the manifold tangent vectors.</p>

    <p>Manifold Tangent Classifier works in two parts:</p>
    <ol>
      <li>Use Autoencoders to learn the manifold structures using Unsupervised Learning.</li>
      <li>Use these learned manifolds with tangent prop.</li>
    </ol>

    <p><img src="https://cdn.mathpix.com/snip/images/ouitJqqotxhESaIP5V6enbeHG7ELd2Ye7u3GfWW9RPg.original.fullsize.png" alt="img" width="65%" /><br />
<br /></p>
  </li>
</ol>

<p id="lst-p"><strong style="color: red">Notes:</strong></p>
<ul>
  <li>A practical rule for choosing a regularizer:
    <ul>
      <li>Stochastic noise is “high frequency”</li>
      <li>Deterministic noise is also non-smooth</li>
    </ul>

    <p>Thus, we should constrain learning towards smoother hypotheses. I.E. fit the signal more than you fit the noise (which is non-smooth). We end up harming both, but harming the irregular, non-smooth noise more.</p>
  </li>
  <li><strong>Regularization does two things - reduce fit to noise AND reduce overfitting</strong>:<br />
  <img src="/main_files/dl_book/regularization/5.png" alt="img" width="100%" /></li>
  <li><strong>Regularization Recommendations (Practical)</strong>:<br />
  <button class="showText" value="show" onclick="showTextPopHide(event);">List of Recommendations</button>
    <ul hidden="">
      <li>You should always consider using regularization, unless you have a very large dataset, e.g. big-data scale.
        <blockquote>
          <p>“Unless your training set contains tens of millions of examples or more, you should include some mild forms of regularization from the start.”<br />
  — Page 426, Deep Learning, 2016.</p>
        </blockquote>
      </li>
      <li>A good general recommendation is to design a neural network structure that is under-constrained and to use regularization to reduce the likelihood of overfitting.
        <blockquote>
          <p>“… controlling the complexity of the model is not a simple matter of finding the model of the right size, with the right number of parameters. Instead, … in practical deep learning scenarios, we almost always do find—that the best fitting model (in the sense of minimizing generalization error) is a large model that has been regularized appropriately.”<br />
  — Page 229, Deep Learning, 2016.</p>
        </blockquote>
      </li>
      <li>Early stopping should almost universally be used in addition to a method to keep weights small during training.
        <blockquote>
          <p>“Early stopping should be used almost universally.”<br />
  — Page 426, Deep Learning, 2016.</p>
        </blockquote>
      </li>
      <li>Some more specific recommendations include:<br />
  These recommendations would suit Multilayer Perceptrons and Convolutional Neural Networks.
        <ul>
          <li><strong>Classical:</strong> use early stopping and weight decay (L2 weight regularization).</li>
          <li><strong>Alternate:</strong> use early stopping and added noise with a weight constraint.</li>
          <li><strong>Modern:</strong> use early stopping and dropout, in addition to a weight constraint.</li>
        </ul>
      </li>
      <li>Some recommendations for <strong>RNNs</strong> include:
        <ul>
          <li><strong>Classical:</strong> use early stopping with added weight noise and a weight constraint such as maximum norm.</li>
          <li><strong>Modern:</strong> use early stopping with a backpropagation-through-time-aware version of dropout and a weight constraint.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Where we (Hadamard) define <strong>Well-Posed Problems</strong> as having the properties (1) A Solution Exists (2) It is Unique (3) It’s behavior changes continuously with the initial conditions. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>So, you can think of the NFL theorems as providing some kind of theoretical justification for regularization or theoretical understanding that helps us see what the role of regularization is and provides some partial explanation for the empirical observation that it seems to often be effective. <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>More generally, we could regularize the parameters to be near any specific point in space and, surprisingly, still get a regularization effect, but better results will be obtained for a value closer to the true one, with zero being a default value that makes sense when we do not know if the correct value should be positive or negative. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>The approximation is perfect if the objective function is truly quadratic, as in the case of <strong>linear regression w/ MSE</strong>. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>The architectures were constructed such that many of the parameters in the classifier model could be paired to corresponding parameters in the unsupervised model. <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>Here we use a uniform distribution over \(\mu\) to simplify the presentation, but nonuniform distributions are also possible. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>


      <footer class="site-footer">
    <!--   <span class="site-footer-owner"><a href="http://localhost:8889">Ahmad Badary</a> is maintained by <a href="http://ahmedbadary.ml">Ahmad Badary</a>.</span> -->
    
<!--  -->
    <div class="wrapper">
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
            <span class="site-footer-owner"><a href="http://localhost:8889">Site</a> maintained by <a href="http://ahmedbadary.ml">Ahmad Badary</a>.</span>
    <span class="site-footer-credits">
        <p>
            &copy; 2017. All rights reserved.
        </p> 
    </span>
            </div>
            <div class="footer-col footer-col-2">
            <div><p>         </p></div>
            </div>
            <div class="footer-col footer-col-3">
                <ul class="social-media-list">
                    
                      <li>
                        <a href="https://github.com/AhmedBadary">
                          <i class="fa fa-github"></i> GitHub
                        </a>
                      </li>
                    
                    
                      <li>
                        <a href="https://linkedin.com/in/ahmad-badary-656098121/">
                          <i class="fa fa-linkedin"></i> LinkedIn
                        </a>
                      </li>
                    
                    
                      <li>
                        <a href="https://www.facebook.com/ahmed.thabet.94">
                          <i class="fa fa-facebook"></i> Facebook
                        </a>
                      </li>
                    
                </ul>
            </div>
        </div>
    </div>
<!--  -->
</footer>


    </section>

  </body>

<!-- Table of Content Script -->
<script type="text/javascript">
var bodyContents = $(".bodyContents1");
$("<ol>").addClass("TOC1ul").appendTo(".TOC1");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC1ul");
     });
// 
var bodyContents = $(".bodyContents2");
$("<ol>").addClass("TOC2ul").appendTo(".TOC2");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC2ul");
     });
// 
var bodyContents = $(".bodyContents3");
$("<ol>").addClass("TOC3ul").appendTo(".TOC3");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC3ul");
     });
//
var bodyContents = $(".bodyContents4");
$("<ol>").addClass("TOC4ul").appendTo(".TOC4");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC4ul");
     });
//
var bodyContents = $(".bodyContents5");
$("<ol>").addClass("TOC5ul").appendTo(".TOC5");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC5ul");
     });
//
var bodyContents = $(".bodyContents6");
$("<ol>").addClass("TOC6ul").appendTo(".TOC6");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC6ul");
     });
//
var bodyContents = $(".bodyContents7");
$("<ol>").addClass("TOC7ul").appendTo(".TOC7");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC7ul");
     });
//
var bodyContents = $(".bodyContents8");
$("<ol>").addClass("TOC8ul").appendTo(".TOC8");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC8ul");
     });
//
var bodyContents = $(".bodyContents9");
$("<ol>").addClass("TOC9ul").appendTo(".TOC9");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC9ul");
     });

</script>

<!-- VIDEO BUTTONS SCRIPT -->
<script type="text/javascript">
  function iframePopInject(event) {
    var $button = $(event.target);
    // console.log($button.parent().next());
    if ($button.attr('value') == 'show') {
        $button.attr('value', 'hide');
        $figure = $("<div>").addClass("video_container");
        $iframe = $("<iframe>").appendTo($figure);
        $iframe.attr("src", $button.attr("src"));
        // $iframe.attr("frameborder", "0");
        $iframe.attr("allowfullscreen", "true");
        $iframe.css("padding", "4px 6px");
        $button.next().css("display", "block");
        $figure.appendTo($button.next());
        $button.text("Hide Video")
    } else {
        $button.attr('value', 'show');
        $button.next().html("");
        $button.text("Show Video")
    }
}
</script>

<!-- BUTTON TRY -->
<script type="text/javascript">
  function iframePopA(event) {
    event.preventDefault();
    var $a = $(event.target).parent();
    console.log($a);
    if ($a.attr('value') == 'show') {
        $a.attr('value', 'hide');
        $figure = $("<div>");
        $iframe = $("<iframe>").addClass("popup_website_container").appendTo($figure);
        $iframe.attr("src", $a.attr("href"));
        $iframe.attr("frameborder", "1");
        $iframe.attr("allowfullscreen", "true");
        $iframe.css("padding", "4px 6px");
        $a.next().css("display", "block");
        $figure.appendTo($a.next().next());
        // $a.text("Hide Content")
        $('html, body').animate({
            scrollTop: $a.offset().top
        }, 1000);
    } else {
        $a.attr('value', 'show');
        $a.next().next().html("");
        // $a.text("Show Content")
    }

    $a.next().css("display", "inline");
}
</script>


<!-- TEXT BUTTON SCRIPT - INJECT -->
<script type="text/javascript">
  function showTextPopInject(event) {
    var $button = $(event.target);
    var txt = $button.attr("input");
    console.log(txt);
    if ($button.attr('value') == 'show') {
        $button.attr('value', 'hide');
        $p = $("<p>");
        $p.html(txt);
        $button.next().css("display", "block");
        $p.appendTo($button.next());
        $button.text("Hide Content")
    } else {
        $button.attr('value', 'show');
        $button.next().html("");
        $button.text("Show Content")
    }

}
</script>

<!-- TEXT BUTTON SCRIPT - HIDDEN / HIDE / SHOW / HIDE/SHOW -->
<script type="text/javascript">
  function showTextPopHide(event) {
    var $button = $(event.target);
    // var txt = $button.attr("input");
    var txt = $button.text();
    if ($button.attr('value') == 'show') {
        $button.attr('value', 'hide');
        $button.next().removeAttr("hidden");
        $button.text(txt + " - Hide Content");
    } else {
        $button.attr('value', 'show');
        $button.next().attr("hidden", "");
        $button.text(txt.replace(" - Hide Content",""));
    }
}
</script>

<!-- TEXT BUTTON SCRIPT - HIDDEN / HIDE / SHOW / HIDE/SHOW -->
<script type="text/javascript">
  function showText_withParent_PopHide(event) {
    var $button = $(event.target);
    var $parent = $button.parent();
    var txt = $button.text();
    if ($button.attr('value') == 'show') {
        $button.attr('value', 'hide');
        $parent.next().removeAttr("hidden");
        $button.text(txt + " - Hide Content");
    } else {
        $button.attr('value', 'show');
        $parent.next().attr("hidden", "");
        $button.text(txt.replace(" - Hide Content",""));
    }
}
</script>

<!-- Print / Printing / printme -->
<!-- <script type="text/javascript">
i = 0

for (var i = 1; i < 6; i++) {
    var bodyContents = $(".bodyContents" + i);
    $("<p>").addClass("TOC1ul")  .appendTo(".TOC1");
    bodyContents.each(function(index, element) {
        var paragraph = $(element);
        $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC1ul");
         });
} 
</script>
 -->
 
</html>

