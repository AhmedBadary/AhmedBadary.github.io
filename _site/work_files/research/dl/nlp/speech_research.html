<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta charset="UTF-8">
  <title>Ahmad Badary</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/cayman.css">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="shortcut icon" href="/main_files/favicon.ico" />
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="/css/customStyle.css">
  <title> » Ahmad Badary</title>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
</head>

  <body>
    <nav class="main-nav">
    <a href="https://ahmedbadary.github.io/" class="main-nav-logo">
        <img src="/main_files/logo.png">
    </a>
    <ul id="menu-main" class="main-nav-items">
        <li id="menu-item-1859" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-home menu-item-1859">
            <a href="/">Home</a>
        </li>
        <li id="menu-item-2869" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2869">
            <a href="/work">Work</a>
        </li>
        <li id="menu-item-1892" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-1892">
            <a href="/projects">Projects</a>
        </li>
        <li id="menu-item-1858" class="menu-item menu-item-type-post_type menu-item-object-page current_page_parent menu-item-1858">
            <a href="/blog">Blog</a>
        </li>
        <li id="menu-item-1862" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-1862">
            <a href="/about">About</a>
        </li>
    </ul>
</nav>


<section class="page-header">
  <h1 class="project-name">ASR <br /> Research Papers</h1>
  <h2 class="project-tagline"></h2>
  <a href="/#" class="btn">Home</a>
  <a href="/work" class="btn">Work-Space</a>
  <a href= /work_files/research/dl/nlp.html class="btn">Previous</a>
</section>

<!-- <div>
  <ul class="posts">
    
      <li><span>02 Jan 2014</span> &raquo; <a href="/2014/01/02/introducing-Ahmad/">Introducing Ahmad</a></li>
    
  </ul>
</div> -->


    <section class="main-content">
      
      <div class="TOC">
  <h1 id="table-of-contents">Table of Contents</h1>

  <ul class="TOC1">
    <li><a href="#content1">Deep Speech</a></li>
  </ul>
  <ul class="TOC2">
    <li><a href="#content2">Towards End-to-End Speech Recognition with Recurrent Neural Networks</a></li>
  </ul>
  <ul class="TOC3">
    <li><a href="#content3">Attention-Based Models for Speech Recognition</a></li>
  </ul>
  <ul class="TOC4">
    <li><a href="#content4">A Neural Transducer</a></li>
  </ul>
  <ul class="TOC5">
    <li><a href="#content5">Deep Speech 2</a></li>
  </ul>
  <ul class="TOC6">
    <li><a href="#content6">Listen, Attend and Spell (LAS)</a></li>
  </ul>
  <ul class="TOC7">
    <li><a href="#content7">State of the Art Speech Recognition w/ Sequence Modeling</a></li>
  </ul>
  <ul class="TOC8">
    <li><a href="#content8">Very Deep Convolutional Networks for End-To-End Speech Recognition</a></li>
  </ul>
</div>

<hr />
<hr />

<h2 id="content1">Deep Speech</h2>

<ol>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents1" id="bodyContents11">Introduction:</strong></dt>
      <dd>This paper takes a first attempt at an End-to-End system for ASR.</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents1" id="bodyContents12">Structure:</strong></dt>
      <dd>
        <ul>
          <li><strong>Input</strong>: vector of speech spectrograms
            <ul>
              <li>An <em><strong>utterance</strong></em> \(x^{(i)}\): is a time-series of length \(T^{(i)}\) composed of time-slices where each is a vector of audio (spectrogram) features \(x_{t,p}^{(i)}, t=1,...,T^{(i)}\), where \(p\) denotes the power of the p’th frequency bin in the audio frame at time \(t\).</li>
            </ul>
          </li>
          <li><strong>Output</strong>: English text transcript \(y\)</li>
        </ul>
      </dd>
      <dd>
        <ul>
          <li><strong>Goal</strong>:<br />
  The goal of the RNN is to convert an input sequence \(x\) into a sequence of character probabilities for the transcription \(y\), with \(\tilde{y}_t = P(c_t\vert x)\), where \(c_t \in \{\text{a, b, c, } \ldots \text{,  z, space,  apostrophe, blank}\}\).</li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents1" id="bodyContents13">Strategy:</strong></dt>
      <dd>The goal is to replace the multi-part model with a single RNN network that captures as much of the information needed to do transcription in a single system.</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents1" id="bodyContents14">Solves:</strong></dt>
      <dd>
        <ul>
          <li>Previous models only used DNNs as a single component in a complex pipeline.<br />
  NNs are trained to classify <strong>individual frames of acoustic data</strong>, and then, their output distributions are reformulated as emission probabilities for a HMM.<br />
  In this case, the objective function used to train the networks is therefore substantially different from the true performance measure (sequence-level transcription accuracy.<br />
  This leads to problems where one system might have an improved accuracy rate but the overall transcription accuracy can still decrease.</li>
          <li>An additional problem is that the frame-level training targets must be inferred from the alignments determined by the HMM. This leads to an awkward iterative procedure, where network retraining is alternated with HMM re-alignments to generate more accurate targets.</li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents1" id="bodyContents15">Key Insights:</strong></dt>
      <dd>
        <ul>
          <li>As an <strong>End-to-End</strong> model, this system avoids the problems of <strong>multi-part</strong> systems that lead to inconsistent training criteria and difficulty of integration. <br />
  The network is trained directly on the text transcripts: no phonetic representation (and hence no pronunciation dictionary or state tying) is used.</li>
          <li>Using <strong>CTC</strong> objective, the system is able to better approximate and solve the alignment problem avoiding HMM realignment training.<br />
  Since CTC integrates out over all possible input-output alignments, no forced alignment is required to provide training targets.</li>
          <li>The Dataset is augmented with newly synthesized data and modified to include all the variations and effects that face ASR problems.  <br />
  This greatly increases the system performance on particularly noisy/affected speech.</li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents1" id="bodyContents16">Preparing Data (Pre-Processing):</strong></dt>
      <dd>The paper uses <strong>spectrograms</strong> of power normalized audio clips as features.</dd>
      <dd><img src="/main_files/dl/nlp/speech_research/2.png" alt="img" width="60%" /></dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents1" id="bodyContents17">Architecture:</strong></dt>
      <dd>The system is composed of:
        <ul>
          <li>An <strong>RNN</strong>:
            <ul>
              <li>5 layers of <strong>hidden units</strong>:
                <ul>
                  <li>3 Layer of <strong>Feed-forward Nets</strong>:
                    <ul>
                      <li>For the <strong>input layer</strong>, the output depends on the spectrogram frame \(x_t\) along with a context of \(C\) frames on each side.
                        <blockquote>
\[C \in \{5, 7, 9\}\]
                        </blockquote>
                      </li>
                      <li>The non-recurrent layers operate on independent data for each time step:<br />
  \(h_t^{(l)} = g(W^{(l)} h_{(t)}^{(l-1)} + b^{(l)}),\)<br />
  where \(g(z) = \min \{\max \{0, z\}, 20\}\) is the <em>clipped RELU</em>.</li>
                    </ul>
                  </li>
                  <li>2 layers of <strong>Recurrent Nets</strong>:
                    <ul>
                      <li>1 layer of a <strong>Bi-LSTM</strong>:
                        <ul>
                          <li>Includes two sets of hidden units: 
  A set with forward recurrence \(h^{(f)}\)<br />
  A set with backward recurrence \(h^{(b)}\):<br />
  \(h_t^{(f)} = g(W^{(4)}h_t^{(3)} + W_r^{(b)} h_{t-1}^{(b)} + b ^{(4)}) \\ 
  h_t^{(b)} = g(W^{(4)}h_t^{(3)} + W_r^{(b)} h_{t+1}^{(b)} + b ^{(4)})\)
                            <blockquote>
                              <p>Note that \(h^{(f)}\) must be computed sequentially from \(t = 1\) to \(t = T^{(i)}\) for the i’th utterance, while the units \(h^{(b)}\) must be computed sequentially in reverse from \(t = T^{(i)}\) to \(t = 1\).</p>
                            </blockquote>
                          </li>
                        </ul>
                      </li>
                      <li>1 layer of <strong>Feed-forward Nets</strong>:
                        <ul>
                          <li>The fifth (non-recurrent) layer takes both the forward and backward units as inputs:<br />
  \(h_t^{(5)} = g(W ^{(5)}h_t ^{(4)} + b ^{(5)}),\)<br />
  where \(h_t^{(4)} = h_t^{(f)} + h_t^{(b)}\)</li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>An <strong>Output</strong> layer made of a standard <strong>softmax function</strong> that yields the predicted character probabilities for each time-slice \(t\) and character \(k\) in the alphabet: <br />
  \(\displaystyle{h _{(t,k)} ^{(6)} = \hat{y} _{(t,k)} = P(c_t = k \vert x) = \dfrac{\exp (W_k ^{(6)} h_t ^{(5)} + b_k ^{(6)})}{\sum_j \exp (W_j ^{(6)}h_t ^{(5)} + b_j ^{(6)})}},\)<br />
  where \(W_k ^{(6)}\) and \(b_k ^{(6)}\) denote the k’th column of the weight matrix and k’th bias.</li>
            </ul>
          </li>
          <li>A <em><strong>CTC</strong></em> <strong>Loss Function</strong> \(\mathcal{L}(\hat{y}, y)\)</li>
          <li>An <em><strong>N-gram Language Model</strong></em></li>
          <li>A <strong>combined Objective Function</strong>:</li>
        </ul>
      </dd>
      <dd>
\[Q(c) = \log (P(x \vert x)) + \alpha \log (P_{\text{LM}}(c) + \beta \text{word_count}(c))\]
      </dd>
      <dd><img src="/main_files/dl/nlp/speech_research/1.png" alt="img" width="80%" /></dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents1" id="bodyContents18">Algorithm:</strong></dt>
      <dd>
        <ul>
          <li>Given the output \(P(c \vert x)\) of the RNN: perform a <strong>search</strong> to find the sequence of characters \(c_1, c_2, ...\) that is most probable according to both:
            <ol>
              <li>The RNN Output</li>
              <li>The Language Model</li>
            </ol>
          </li>
          <li>We maximize the combined objective:<br />
  \(Q(c) = \log (P(x \vert x)) + \alpha \log (P_{\text{LM}}(c) + \beta \text{word_count}(c))\)<br />
  where the term \(P_{\text{lm}} denotes the probability of the sequence\)c$$ according to the N-gram model.</li>
          <li>The objective is maximized using a highly optimized <strong>beam search</strong> algorithm
            <blockquote>
              <p>beam size: 1000-8000</p>
            </blockquote>
          </li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents1" id="bodyContents19">Training:</strong></dt>
      <dd>
        <ul>
          <li>The gradient of the CTC Loss \(\nabla_{\hat{y}} \mathcal{L}(\hat{y}, y)\) with respect to the net outputs given the ground-truth character sequence \(y\) is computed</li>
        </ul>
      </dd>
      <dd>
        <ul>
          <li>Nesterov’s Accelerated gradient</li>
          <li>Nesterov Momentum</li>
          <li>Annealing the learning rate by a constant factor</li>
          <li>Dropout</li>
          <li>Striding – shortening the recurrent layers by taking strides of size \(2\).<br />
  The unrolled RNN will have <strong>half</strong> as many steps.
            <blockquote>
              <p>similar to a convolutional network with a step-size of 2 in the first layer.</p>
            </blockquote>
          </li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents1" id="bodyContents110">Parameters:</strong></dt>
      <dd>
        <ul>
          <li><strong>Momentum</strong>: \(0.99\)</li>
          <li><strong>Dropout</strong>: \(5-10 \%\) (FFN only)</li>
          <li><strong>Trade-Off Params</strong>: use cross-validation for \(\alpha, \beta\)</li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents1" id="bodyContents111">Issues/The Bottleneck:</strong></dt>
      <dd></dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents1" id="bodyContents112">Results:</strong></dt>
      <dd>
        <ul>
          <li><strong>SwitchboardHub5’00</strong>  (
WER):
            <ul>
              <li>Standard: \(16.0\%\)</li>
              <li>w/Lexicon of allowed words: \(21.9\%\)</li>
              <li>Trigram LM: \(8.2\%\)</li>
              <li>w/Baseline system: \(6.7\%\)</li>
            </ul>
          </li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents1" id="bodyContents113">Discussion:</strong></dt>
      <dd>
        <ul>
          <li><strong>Why avoid LSTMs</strong>:<br />
  One disadvantage of LSTM cells is that they require computing and storing multiple gating neuron responses at each step.<br />
  Since the forward and backward recurrences are sequential, this small additional cost can become a computational bottleneck.</li>
        </ul>
      </dd>
      <dd>
        <ul>
          <li><strong>Why a homogeneous model</strong>:<br />
   By using a homogeneous model we have made the computation of the recurrent activations as efficient as possible: computing the ReLu outputs involves only a few highly optimized BLAS operations on the GPU and a single point-wise nonlinearity.</li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents1" id="bodyContents114">Further Development:</strong></dt>
      <dd></dd>
    </dl>
  </li>
</ol>

<hr />

<h2 id="content2">Towards End-to-End Speech Recognition with Recurrent Neural Networks</h2>

<ol>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents2" id="bodyContents21">Introduction:</strong></dt>
      <dd>This paper presents an ASR system that directly transcribes audio data with text, <strong>without</strong> requiring an <em>intermediate phonetic representation</em>.</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents2" id="bodyContents22">Structure:</strong></dt>
      <dd>
        <ul>
          <li><strong>Input</strong>:</li>
          <li><strong>Output</strong>:</li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents2" id="bodyContents23">Strategy:</strong></dt>
      <dd>The goal of this paper is a system where as much of the speech pipeline as possible is replaced by a single recurrent neural network (RNN) architecture.<br />
The language model, however, will be lacking due to the limitation of the audio data to learn a strong LM.</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents2" id="bodyContents24">Solves:</strong></dt>
      <dd>
        <ul>
          <li>First attempts used <strong>RNNs</strong> or standard <strong>LSTMs</strong>. These models lacked the complexity that was needed to capture all the models required for ASR.</li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents2" id="bodyContents25">Key Insights:</strong></dt>
      <dd>
        <ul>
          <li>The model uses Bidirectional LSTMs to capture the nuances of the problem.</li>
          <li>The system uses a new <strong>objective function</strong> that trains the network to directly optimize the <strong>WER</strong>.</li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents2" id="bodyContents26">Preparing the Data (Pre-Processing):</strong></dt>
      <dd>The paper uses <strong>spectrograms</strong> as a minimal preprocessing scheme.</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents2" id="bodyContents27">Architecture:</strong></dt>
      <dd>The system is composed of:
        <ul>
          <li>A <strong>Bi-LSTM</strong></li>
          <li>A <strong>CTC output layer</strong></li>
          <li>A <strong>combined objective function</strong>:<br />
  The new objective function at allows an RNN to be trained to optimize the expected value of an arbitrary loss function defined over output transcriptions (such as <strong>WER</strong>).<br />
  Given input sequence \(x\), the distribution \(P(y\vert x)\) over transcriptions sequences \(y\) defined by CTC, and a real-valued transcription loss function \(\mathcal{L}(x, y)\), the expected transcription loss \(\mathcal{L}(x)\) is defined:
            <p>$$\begin{align}
      \mathcal{L}(x) &amp;= \sum_y P(y \vert x)\mathcal{L}(x,y) \\ 
      &amp;= \sum_y \sum_{a \in \mathcal{B}^{-1}(y)} P(a \vert x)\mathcal{L}(x,y) \\
      &amp;= \sum_a P(a \vert x)\mathcal{L}(x,\mathcal{B}(a))
      \end{align}$$</p>
            <p><button class="showText" value="show" onclick="showTextPopHide(event);">Show Derivation</button>
 <img src="/main_files/dl/nlp/speech_research/3.png" alt="Approximation and Differentiation" hidden="" width="80%" /></p>
          </li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents2" id="bodyContents28">Algorithm:</strong></dt>
      <dd></dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents2" id="bodyContents29">Issues/The Bottleneck:</strong></dt>
      <dd></dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents2" id="bodyContents210">Results:</strong></dt>
      <dd>
        <ul>
          <li><strong>WSJC</strong> (
WER):
            <ul>
              <li>Standard: \(27.3\%\)</li>
              <li>w/Lexicon of allowed words: \(21.9\%\)</li>
              <li>Trigram LM: \(8.2\%\)</li>
              <li>w/Baseline system: \(6.7\%\)</li>
            </ul>
          </li>
        </ul>
      </dd>
    </dl>
  </li>
</ol>

<hr />

<h2 id="content3">Attention-Based Models for Speech Recognition</h2>

<ol>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents3" id="bodyContents31">Introduction:</strong></dt>
      <dd>This paper introduces and extends the attention mechanism with features needed for ASR. It adds location-awareness to the attention mechanism to add robustness against different lengths of utterances.</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents3" id="bodyContents32">Motivation:</strong></dt>
      <dd>Learning to recognize speech can be viewed as learning to generate a sequence (transcription) given another sequence (speech).<br />
From this perspective it is similar to machine translation and handwriting synthesis tasks, for which attention-based methods have been found suitable.</dd>
      <dd><strong>How ASR differs:</strong><br />
Compared to <em>Machine Translation</em>, speech recognition differs by requesting much longer input sequences which introduces a challenge of distinguishing similar speech fragments in a single utterance.
        <blockquote>
          <p>thousands of frames instead of dozens of words</p>
        </blockquote>
      </dd>
      <dd>It is different from <em>Handwriting Synthesis</em>, since the input sequence is much noisier and does not have a clear structure.</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents3" id="bodyContents32">Structure:</strong></dt>
      <dd>
        <ul>
          <li><strong>Input</strong>: \(x=(x_1, \ldots, x_{L'})\) is a sequence of feature vectors
            <ul>
              <li>Each feature vector is extracted from a small overlapping window of audio frames</li>
            </ul>
          </li>
          <li><strong>Output</strong>: \(y\) a sequence of <strong>phonemes</strong></li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents3" id="bodyContents33">Strategy:</strong></dt>
      <dd>The goal of this paper is a system, that uses attention-mechanism with location awareness, whose performance is comparable to that of the conventional approaches.</dd>
      <dd>
        <ul>
          <li>For each generated phoneme, an attention mechanism selects or weighs the signals produced by a trained feature extraction mechanism at potentially all of the time steps in the input sequence (speech frames).</li>
          <li>The weighted feature vector then helps to condition the generation of the next element of the output sequence.</li>
          <li>Since the utterances in this dataset are rather short (mostly under 5 seconds), we measure the ability of the considered models in recognizing much longer utterances which were created by artificially concatenating the existing utterances.</li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents3" id="bodyContents34">Solves:</strong></dt>
      <dd>
        <ul>
          <li><strong>Problem</strong>:<br />
  The <a href="https://arxiv.org/abs/1409.0473">attention-based model proposed for NMT</a> demonstrates vulnerability to the issue of similar speech fragments with <strong>longer, concatenated utterances</strong>.<br />
  The paper argues that  this model adapted to track the absolute location in the input sequence of the content it is recognizing, a strategy feasible for short utterances from the original test set but inherently unscalable.</li>
          <li><strong>Solution</strong>:<br />
  The attention-mechanism is modified to take into account the location of the focus from the previous step and the features of the input sequence by adding as inputs to the attention mechanism auxiliary <em><strong>Convolutional Features</strong></em> which are extracted by convolving the attention weights from the previous step with trainable filters.</li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents3" id="bodyContents35">Key Insights:</strong></dt>
      <dd>
        <ul>
          <li>Introduces attention-mechanism to ASR</li>
          <li>The attention-mechanism is modified to take into account:
            <ul>
              <li>location of the focus from the previous step</li>
              <li>features of the input sequence</li>
            </ul>
          </li>
          <li>Proposes a generic method of adding location awareness to the attention mechanism</li>
          <li>Introduce a modification of the attention mechanism to avoid concentrating the attention on a single frame</li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents3" id="bodyContents37">Attention-based Recurrent Sequence Generator (ARSG):</strong></dt>
      <dd>is a recurrent neural network that stochastically generates an output sequence \((y_1, \ldots, y_T)\) from an input \(x\).<br />
 In practice, \(x\) is often processed by an <strong>encoder</strong> which outputs a sequential input representation \(h = (h_1, \ldots, h_L)\) more suitable for the attention mechanism to work with.</dd>
      <dd>The <strong>Encoder</strong>: a deep bidirectional recurrent network.<br />
It forms a sequential representation h of length \(L = L'\).</dd>
      <dd><strong style="color: red">Structure:</strong>
        <ul>
          <li><em><strong>Input</strong></em>: \(x = (x_1, \ldots, x_{L'})\) is a sequence of feature vectors
            <blockquote>
              <p>Each feature vector is extracted from a small overlapping window of audio frames.</p>
            </blockquote>
          </li>
          <li><em><strong>Output</strong></em>: \(y\) is a sequence of phonemes</li>
        </ul>
      </dd>
      <dd><strong style="color: red">Strategy:</strong>  <br />
At the \(i\)-th step an ARSG generates an output \(y_i\) by focusing on the relevant elements of \(h\):</dd>
      <dd>
\[\begin{align}
\alpha_i &amp;= \text{Attend}(s_{i-1}, \alpha _{i-1}), h) &amp; (1) \\
g_i &amp;= \sum_{j=1}^L \alpha_{i,j} h_j &amp; (2) //
y_i &amp;\sim \text{Generate}(s_{i-1}, g_i) &amp; (3)  
\end{align}\]
      </dd>
      <dd>where \(s_{i−1}\) is the \((i − 1)\)-th state of the recurrent neural network to which we refer as the <strong>generator</strong>, \(\alpha_i \in \mathbb{R}^L\) is a vector of the <em>attention weights</em>, also often called the <strong>alignment</strong>; and \(g_i\) is the <strong>glimpse</strong>.<br />
The step is completed by computing a <em><strong>new generator state</strong></em>:</dd>
      <dd>
\[s_i = \text{Recurrency}(s_{i-1}, g_i, y_i)\]
      </dd>
      <dd>where the <em>Recurrency</em> is an RNN.</dd>
      <dd><img src="/main_files/dl/nlp/speech_research/4.png" alt="img" width="100%" /></dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents3" id="bodyContents312">Attention-mechanism Types and Speech Recognition:</strong></dt>
      <dd><strong style="color: red">Types of Attention:</strong>
        <ul>
          <li>(Generic) Hybrid Attention: \(\alpha_i = \text{Attend}(s_{i-1}, \alpha_{i-1}, h)\)</li>
          <li>Content-based Attention: \(\alpha_i = \text{Attend}(s_{i-1}, h)\) <br />
  In this case, Attend is often implemented by scoring each element in h separately and normalizing the scores:<br />
  \(e_{i,j} = \text{Score}(s_{i-1}, h_j) \\\) 
    \(\alpha_{i,j} = \dfrac{\text{exp} (e_{i,j}) }{\sum_{j=1}^L \text{exp}(e_{i,j})}\)
            <ul>
              <li><strong>Limitations</strong>:<br />
  The main limitation of such scheme is that identical or very similar elements of \(h\) are scored equally regardless of their position in the sequence.<br />
  Often this issue is partially alleviated by an encoder such as e.g. a BiRNN or a deep convolutional network that encode contextual information into every element of h . However, capacity of h elements is always limited, and thus disambiguation by context is only possible to a limited extent.</li>
            </ul>
          </li>
          <li>Location-based Attention: \(\alpha_i = \text{Attend}(s_{i-1}, \alpha_{i-1})\) <br />
  a location-based attention mechanism computes the alignment from the generator state and the previous alignment only.
            <ul>
              <li><strong>Limitations</strong>:<br />
  the model would have to predict the distance between consequent phonemes using \(s_{i−1}\) only, which we expect to be hard due to large variance of this quantity.</li>
            </ul>
          </li>
        </ul>
      </dd>
      <dd>Thus, we conclude that the <strong><em>Hybrid Attention</em></strong> mechanism is a suitable candidate.<br />
Ideally, we need an attention model that uses the previous alignment \(\alpha_{i-1}\) to select a short list of elements from \(h\), from which the content-based attention, will select the relevant ones without confusion.</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents3" id="bodyContents36">Preparing the Data (Pre-Processing):</strong></dt>
      <dd>The paper uses <strong>spectrograms</strong> as a minimal preprocessing scheme.</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents3" id="bodyContents37">Architecture:</strong></dt>
      <dd>Start with the <strong>ARSG</strong>-based model:
        <ul>
          <li><strong>Encoder</strong>: is a <strong>Bi-RNN</strong></li>
        </ul>
        <p>$$e_{i,j} = w^T \tanh (Ws_{i-1} + Vh_j + b)$$</p>
        <ul>
          <li><strong>Attention</strong>: Content-Based Attention extended for <em>location awareness</em>
            <p>$$e_{i,j} = w^T \tanh (Ws_{i-1} + Vh_j + Uf_{i,j} + b)$$</p>
          </li>
        </ul>
      </dd>
      <dd><strong>Extending the Attention Mechanism:</strong><br />
Content-Based Attention extended for <em>location awareness</em> by making it take into account the alignment produced at the previous step.
        <ul>
          <li>First, we extract \(k\) vectors \(f_{i,j} \in \mathbb{R}^k\) for every position \(j\) of the previous alignment \(\alpha_{i−1}\) by convolving it with a matrix \(F \in \mathbb{R}^{k\times r}\):
            <p>$$f_i = F * \alpha_{i-1}$$</p>
          </li>
          <li>These additional vectors \(f_{i,j} are then used by the scoring mechanism\)e_{i,j}$$:
            <p>$$e_{i,j} = w^T \tanh (Ws_{i-1} + Vh_j + Uf_{i,j} + b)$$</p>
          </li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents3" id="bodyContents38">Algorithm:</strong></dt>
      <dd></dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents3" id="bodyContents39">Issues/The Bottleneck:</strong></dt>
      <dd></dd>
    </dl>
  </li>
</ol>

<!-- 10. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents3 #bodyContents310}  
    :    -->

<hr />

<h2 id="content4">A Neural Transducer</h2>

<!-- 1. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents4 #bodyContents41}  
    :   

2. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents4 #bodyContents42}  
    :   

3. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents4 #bodyContents43}  
    :   

4. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents4 #bodyContents44}  
    :   

5. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents4 #bodyContents45}  
    :   

6. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents4 #bodyContents46}  
    :   

7. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents4 #bodyContents47}  
    :   

8. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents4 #bodyContents48}  
    :   -->

<hr />

<h2 id="content5">Deep Speech 2</h2>

<ol>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents5" id="bodyContents51">Introduction:</strong></dt>
      <dd>This paper improves on the previous attempt at an End-to-End system for ASR. It increases the complexity of the architecture and is able to achieve high accuracy on two different languages – English and Chinese.</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents5" id="bodyContents52">Structure:</strong></dt>
      <dd>
        <ul>
          <li><strong>Input</strong>: vector of speech spectrograms
            <ul>
              <li>An <em><strong>utterance</strong></em> \(x^{(i)}\): is a time-series of length \(T^{(i)}\) composed of time-slices where each is a vector of audio (spectrogram) features \(x_{t,p}^{(i)}, t=1,...,T^{(i)}\), where \(p\) denotes the power of the p’th frequency bin in the audio frame at time \(t\).</li>
            </ul>
          </li>
          <li><strong>Output</strong>: English text transcript \(y\)</li>
        </ul>
      </dd>
      <dd>
        <ul>
          <li><strong>Goal</strong>:<br />
  The goal of the RNN is to convert an input sequence \(x\) into a sequence of character probabilities for the transcription \(y\), with \(\tilde{y}_t = P(c_t\vert x)\), where \(c_t \in \{\text{a, b, c, } \ldots \text{,  z, space,  apostrophe, blank}\}\).</li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents5" id="bodyContents53">Strategy:</strong></dt>
      <dd>The goal is to replace the multi-part model with a single RNN network that captures as much of the information needed to do transcription in a single system.</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents5" id="bodyContents54">Solves:</strong></dt>
      <dd>
        <ul>
          <li>Previous models only used DNNs as a single component in a complex pipeline.<br />
  NNs are trained to classify <strong>individual frames of acoustic data</strong>, and then, their output distributions are reformulated as emission probabilities for a HMM.<br />
  In this case, the objective function used to train the networks is therefore substantially different from the true performance measure (sequence-level transcription accuracy.<br />
  This leads to problems where one system might have an improved accuracy rate but the overall transcription accuracy can still decrease.</li>
          <li>An additional problem is that the frame-level training targets must be inferred from the alignments determined by the HMM. This leads to an awkward iterative procedure, where network retraining is alternated with HMM re-alignments to generate more accurate targets.</li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents5" id="bodyContents55">Key Insights:</strong></dt>
      <dd>
        <ul>
          <li>As an <strong>End-to-End</strong> model, this system avoids the problems of <strong>multi-part</strong> systems that lead to inconsistent training criteria and difficulty of integration. <br />
  The network is trained directly on the text transcripts: no phonetic representation (and hence no pronunciation dictionary or state tying) is used.</li>
          <li>Using <strong>CTC</strong> objective, the system is able to better approximate and solve the alignment problem avoiding HMM realignment training.<br />
  Since CTC integrates out over all possible input-output alignments, no forced alignment is required to provide training targets.</li>
          <li>The Dataset is augmented with newly synthesized data and modified to include all the variations and effects that face ASR problems.  <br />
  This greatly increases the system performance on particularly noisy/affected speech.</li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents5" id="bodyContents56">Preparing Data (Pre-Processing):</strong></dt>
      <dd>The paper uses <strong>spectrograms</strong> as a minimal preprocessing scheme.</dd>
      <dd><img src="/main_files/dl/nlp/speech_research/2.png" alt="img" width="60%" /></dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents5" id="bodyContents57">Architecture:</strong></dt>
      <dd>The system is composed of:
        <ul>
          <li>An <strong>RNN</strong>:
            <ul>
              <li>5 layers of <strong>hidden units</strong>:
                <ul>
                  <li>3 Layer of <strong>Feed-forward Nets</strong>:
                    <ul>
                      <li>For the <strong>input layer</strong>, the output depends on the spectrogram frame \(x_t\) along with a context of \(C\) frames on each side.
                        <blockquote>
\[C \in \{5, 7, 9\}\]
                        </blockquote>
                      </li>
                      <li>The non-recurrent layers operate on independent data for each time step:<br />
  \(h_t^{(l)} = g(W^{(l)} h_{(t)}^{(l-1)} + b^{(l)}),\)<br />
  where \(g(z) = \min \{\max \{0, z\}, 20\}\) is the <em>clipped RELU</em>.</li>
                    </ul>
                  </li>
                  <li>2 layers of <strong>Recurrent Nets</strong>:
                    <ul>
                      <li>1 layer of a <strong>Bi-LSTM</strong>:
                        <ul>
                          <li>Includes two sets of hidden units: 
  A set with forward recurrence \(h^{(f)}\)<br />
  A set with backward recurrence \(h^{(b)}\):<br />
  \(h_t^{(f)} = g(W^{(4)}h_t^{(3)} + W_r^{(b)} h_{t-1}^{(b)} + b ^{(4)}) \\ 
  h_t^{(b)} = g(W^{(4)}h_t^{(3)} + W_r^{(b)} h_{t+1}^{(b)} + b ^{(4)})\)
                            <blockquote>
                              <p>Note that \(h^{(f)}\) must be computed sequentially from \(t = 1\) to \(t = T^{(i)}\) for the i’th utterance, while the units \(h^{(b)}\) must be computed sequentially in reverse from \(t = T^{(i)}\) to \(t = 1\).</p>
                            </blockquote>
                          </li>
                        </ul>
                      </li>
                      <li>1 layer of <strong>Feed-forward Nets</strong>:
                        <ul>
                          <li>The fifth (non-recurrent) layer takes both the forward and backward units as inputs:<br />
  \(h_t^{(5)} = g(W ^{(5)}h_t ^{(4)} + b ^{(5)}),\)<br />
  where \(h_t^{(4)} = h_t^{(f)} + h_t^{(b)}\)</li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>An <strong>Output</strong> layer made of a standard <strong>softmax function</strong> that yields the predicted character probabilities for each time-slice \(t\) and character \(k\) in the alphabet: <br />
  \(\displaystyle{h _{(t,k)} ^{(6)} = \hat{y} _{(t,k)} = P(c_t = k \vert x) = \dfrac{\exp (W_k ^{(6)} h_t ^{(5)} + b_k ^{(6)})}{\sum_j \exp (W_j ^{(6)}h_t ^{(5)} + b_j ^{(6)})}},\)<br />
  where \(W_k ^{(6)}\) and \(b_k ^{(6)}\) denote the k’th column of the weight matrix and k’th bias.</li>
            </ul>
          </li>
          <li>A <em><strong>CTC</strong></em> <strong>Loss Function</strong> \(\mathcal{L}(\hat{y}, y)\)</li>
          <li>An <em><strong>N-gram Language Model</strong></em></li>
          <li>A <strong>combined Objective Function</strong>:</li>
        </ul>
      </dd>
      <dd>
\[Q(c) = \log (P(x \vert x)) + \alpha \log (P_{\text{LM}}(c) + \beta \text{word_count}(c))\]
      </dd>
      <dd><img src="/main_files/dl/nlp/speech_research/1.png" alt="img" width="80%" /></dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents5" id="bodyContents58">Algorithm:</strong></dt>
      <dd>
        <ul>
          <li>Given the output \(P(c \vert x)\) of the RNN: perform a <strong>search</strong> to find the sequence of characters \(c_1, c_2, ...\) that is most probable according to both:
            <ol>
              <li>The RNN Output</li>
              <li>The Language Model</li>
            </ol>
          </li>
          <li>We maximize the combined objective:<br />
  \(Q(c) = \log (P(x \vert x)) + \alpha \log (P_{\text{LM}}(c) + \beta \text{word_count}(c))\)<br />
  where the term \(P_{\text{lm}} denotes the probability of the sequence\)c$$ according to the N-gram model.</li>
          <li>The objective is maximized using a highly optimized <strong>beam search</strong> algorithm
            <blockquote>
              <p>beam size: 1000-8000</p>
            </blockquote>
          </li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents5" id="bodyContents59">Training:</strong></dt>
      <dd>
        <ul>
          <li>The gradient of the CTC Loss \(\nabla_{\hat{y}} \mathcal{L}(\hat{y}, y)\) with respect to the net outputs given the ground-truth character sequence \(y\) is computed</li>
        </ul>
      </dd>
      <dd>
        <ul>
          <li>Nesterov’s Accelerated gradient</li>
          <li>Nesterov Momentum</li>
          <li>Annealing the learning rate by a constant factor</li>
          <li>Dropout</li>
          <li>Striding – shortening the recurrent layers by taking strides of size \(2\).<br />
  The unrolled RNN will have <strong>half</strong> as many steps.
            <blockquote>
              <p>similar to a convolutional network with a step-size of 2 in the first layer.</p>
            </blockquote>
          </li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents5" id="bodyContents510">Parameters:</strong></dt>
      <dd>
        <ul>
          <li><strong>Momentum</strong>: \(0.99\)</li>
          <li><strong>Dropout</strong>: \(5-10 \%\) (FFN only)</li>
          <li><strong>Trade-Off Params</strong>: use cross-validation for \(\alpha, \beta\)</li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents1" id="bodyContents511">Issues/The Bottleneck:</strong></dt>
      <dd></dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents5" id="bodyContents512">Results:</strong></dt>
      <dd>
        <ul>
          <li><strong>SwitchboardHub5’00</strong>  (
WER):
            <ul>
              <li>Standard: \(16.0\%\)</li>
              <li>w/Lexicon of allowed words: \(21.9\%\)</li>
              <li>Trigram LM: \(8.2\%\)</li>
              <li>w/Baseline system: \(6.7\%\)</li>
            </ul>
          </li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents5" id="bodyContents513">Discussion:</strong></dt>
      <dd>
        <ul>
          <li><strong>Why avoid LSTMs</strong>:<br />
  One disadvantage of LSTM cells is that they require computing and storing multiple gating neuron responses at each step.<br />
  Since the forward and backward recurrences are sequential, this small additional cost can become a computational bottleneck.</li>
        </ul>
      </dd>
      <dd>
        <ul>
          <li><strong>Why a homogeneous model</strong>:<br />
  By using a homogeneous model we have made the computation of the recurrent activations as efficient as possible: computing the ReLu outputs involves only a few highly optimized BLAS operations on the GPU and a single point-wise nonlinearity.</li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents5" id="bodyContents514">Further Development:</strong></dt>
      <dd></dd>
    </dl>
  </li>
</ol>

<hr />

<h2 id="content6">Listen, Attend and Spell (LAS)</h2>

<ol>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents6" id="bodyContents61">Introduction:</strong></dt>
      <dd>This paper presents a a neural network that learns to transcribe speech utterances to characters.  Unlike traditional DNN-HMM models, this model learns all the components of a speech recognizer jointly.</dd>
      <dd>The system has two components: a listener and a speller.</dd>
      <dd><strong>LAS</strong> is based on the sequence to sequence learning framework with attention.</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents6" id="bodyContents62">Structure:</strong></dt>
      <dd>
        <ul>
          <li>
            <p><strong>Input</strong>: \(\mathbb{x} = (x_1, \ldots, x_T)\) a sequence of filter bank spectra (acoustic) features</p>
          </li>
          <li>
            <p><strong>Output</strong>: \(\mathbb{y} = (\text{&lt;sos&gt;}, y_1, \ldots, y_S, \text{&lt;eos&gt;}), y_i \in \{\text{a, b, c, · · · , z, 0, · · · , 9, &lt;spacei,&lt;comma&gt;,&lt;period&gt;,&lt;apostrophe&gt;,&lt;unk&gt; }\}\) the output sequence of characters</p>
          </li>
        </ul>
      </dd>
      <dd>
        <ul>
          <li><strong>Goal</strong>:<br />
  The goal of the RNN is to convert an input sequence \(x\) into a sequence of character probabilities for the transcription \(y\), with \(\tilde{y}_t = P(c_t\vert x)\), where \(c_t \in \{\text{a, b, c, } \ldots \text{,  z, space,  apostrophe, blank}\}\).</li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents6" id="bodyContents63">Strategy:</strong></dt>
      <dd><strong>LAS</strong> is based on the sequence to sequence learning framework with attention.</dd>
      <dd>
        <ul>
          <li>We want to model each character output \(y_i\) as a conditional distribution over the previous characters \(y_{\leq i+1}\) and the input signal \(\mathbb{x}\) using the chain rule:</li>
        </ul>
        <p>$$P(\mathbb{y} \vert \mathbb{x}) = \prod_i P(y_i \vert \mathbb{x}, y_{\leq i+1}) \:\:\:\: (1)$$</p>
        <ul>
          <li></li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents6" id="bodyContents64">Solves:</strong></dt>
      <dd>
        <ul>
          <li><strong>CTC</strong>:<br />
  CTC assumes that the label outputs are conditionally independent of each other</li>
          <li><strong>Seq2Seq</strong>:<br />
  the sequence to sequence approach has only been applied to phoneme sequences, and not trained end-to-end for speech recognition.</li>
          <li></li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents6" id="bodyContents65">Key Insights:</strong></dt>
      <dd>
        <ul>
          <li>Use a pyramidal RNN model for the listener, which reduces the number of time steps that the attention model has to extract relevant information from.<br />
The pyramid structure also reduces the computational complexity.</li>
          <li>Character-based transcription allows the handling of rare and OOV words automatically</li>
          <li>Attention</li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents6" id="bodyContents677">The Model:</strong></dt>
      <dd><strong>Listen</strong>:<br />
Uses a <strong>Bi-directional LSTM</strong> with a pyramid structure.
        <blockquote>
          <p>The pyramid structure is needed to reduce the length \(U\) of \(\mathbf{h}\), from \(T\) , the length of the input \(\mathbb{h}\) , because the input speech signals can be hundreds to thousands of frames long.</p>
        </blockquote>
      </dd>
    </dl>
    <ul>
      <li><strong>Pyramidal LSTM</strong>:<br />
  The output at the i-th time step, from the j-th layer is changed from:
        <p>$$h_i^j = \text{BLSTM}(h_{i-1}^j, h_{i}^{j-1})$$</p>
        <p>to, instead, we concatenate the outputs at consecutive steps of each layer before feeding it to the next layer:</p>
        <p>$$h_i^j = \text{pBLSTM}(h_{i-1}^j, \left[h_{2i}^{j-1}, h_{2i+1}^{j-1}\right])$$</p>
        <blockquote>
          <dl>
            <dt>In the model, we stack 3 pBLSTMs on top of the bottom BLSTM layer to reduce the time resolution \(2^3 = 8\) times.</dt>
            <dd><strong>Attend and Spell:</strong><br />
The function is computed using an <strong>attention-based LSTM transducer</strong>.<br />
At every output step, the transducer produces a probability distribution over the next character conditioned on all the characters seen previously.<br />
The <strong>distribution</strong> for \(y_i\) is a function of the decoder state \(s_i\) and context \(c_i\).<br />
The <strong>decoder state</strong> \(s_i\) is a function of the previous state \(s_{i−1}\), the previously emitted character \(y_{i−1}\) and context \(c_{i−1}\).<br />
The <strong>context vector</strong> \(c_i\) is produced by an attention mechanism:</dd>
          </dl>
        </blockquote>
      </li>
    </ul>
    <p>$$ c_i = \text{AttentionContext}(s_i, \mathbf{h}) \\
    s_i = \text{RNN}(s_{i-1}, y_{i-1}, c_{i-1}) \\
P(y_i \vert \mathbf{x}, y_{\leq i+1}) = \text{CharacterDistribution}(s_i, c_i)$$  </p>
    <p>where <strong>CharacterDistribution</strong> is an <strong>MLP</strong> with softmax outputs over characters, and <strong>RNN</strong> is a 2 layer LSTM.<br />
The <strong>Attention</strong> Mechanism:<br />
At each step \(i\), the attention mechanism, <em>AttentionContext</em> generates a context vector \(c_i\) encapsulating the information in the acoustic signal needed to generate the next character.<br />
The attention model is <strong>content based</strong> - the contents of the decoder state \(s_i\) are matched to the contents of \(h_u\) representing time step \(u\) of \(\mathbf{h}\) to generate an attention vector \(\alpha_i\).<br />
\(\alpha_i\) is used to linearly blend vectors \(h_u\) to create \(c_i\).<br />
Specifically, at each decoder timestep \(i\) , the AttentionContext function computes the scalar energy
\(e_{i,u}\) for each time step \(u\) , using vector \(h_u \in h\) and \(s_i\).<br />
The scalar energy \(e_{i,u}\) is converted into a
probability distribution over times steps (or attention) \(\alpha_i\)  using a softmax function. This is used to create the context vector \(c_i\)  by linearly blending the listener features, \(h_u\), at different time steps:</p>
    <p>  
$$\begin{align}
    e_{i,u} &amp;= &lt;\phi(s_i), \psi(h_u)&gt; \\
    \alpha_{i,u} &amp;= \dfrac{\exp(e_{i,u})}{\sum_u \exp(e_{i,u})} \\
    c_i &amp;= \sum_u \alpha_{i,u}h_u 
    \end{align}
    $$ 
</p>
    <p>where \(\phi\) and \(\psi\) are <strong>MLP</strong> Networks.<br />
On convergence, the \(\alpha_i\)  distribution is typically very sharp, and focused on only a few frames of \(\mathbf{h}\) ; \(c_i\) can be seen as a continuous bag of weighted features of \(\mathbf{h}\).</p>
  </li>
  <li>
    <p><strong style="color: SteelBlue" class="bodyContents6" id="bodyContents66">Preparing Data (Pre-Processing):</strong></p>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents6" id="bodyContents67">Architecture:</strong></dt>
      <dd><img src="/main_files/dl/nlp/speech_research/5.png" alt="img" width="60%" /></dd>
      <dd>
        <ul>
          <li><strong>Encoder (listener):</strong><br />
  An <strong>acoustic model</strong> encoder, whose key operation is <code class="language-plaintext highlighter-rouge">Listen</code>.<br />
  It converts low level speech signals into higher level features.
            <ul>
              <li><strong>(pyramidal) RNN</strong>:
                <ul>
                  <li>
                    <p><strong>Bi-Directional LSTM</strong>:</p>

                    <ul>
                      <li><em><strong>Structure</strong></em>:
                        <ul>
                          <li><em><strong>Input:</strong></em> original signal \(\mathbb{x}\)</li>
                          <li><em><strong>Output:</strong></em> a high level representation \(\mathbf{h} = (h_1, ]ldots, h_U)\), with \(U \leq T\)</li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li><strong>Decoder (speller)</strong>:<br />
  The speller is an <em>attention-based</em> <strong>character decoder</strong>, whose key operation is <code class="language-plaintext highlighter-rouge">AttendAndSpell</code>.<br />
  It converts the higher level features into output utterances by specifying a probability distribution over sequences of characters using the attention mechanism.
            <ul>
              <li><strong>RNN</strong>:
                <ul>
                  <li><em><strong>Structure</strong></em>:
                    <ul>
                      <li><em><strong>Input:</strong></em> features \(\mathbf{h}\)</li>
                      <li><em><strong>Output:</strong></em> a probability distribution over character sequences:   \(\mathbf{h} = (h_1, ]ldots, h_U)\), with \(U \leq T\)</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents6" id="bodyContents68">Algorithm:</strong></dt>
      <dd></dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents6" id="bodyContents69">Training:</strong></dt>
      <dd>
        <ul>
          <li>The gradient of the CTC Loss \(\nabla_{\hat{y}} \mathcal{L}(\hat{y}, y)\) with respect to the net outputs given the ground-truth character sequence \(y\) is computed</li>
        </ul>
      </dd>
      <dd>
        <ul>
          <li>Nesterov’s Accelerated gradient</li>
          <li>Nesterov Momentum</li>
          <li>Annealing the learning rate by a constant factor</li>
          <li>Dropout</li>
          <li>Striding – shortening the recurrent layers by taking strides of size \(2\).<br />
  The unrolled RNN will have <strong>half</strong> as many steps.
            <blockquote>
              <p>similar to a convolutional network with a step-size of 2 in the first layer.</p>
            </blockquote>
          </li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <p><strong style="color: SteelBlue" class="bodyContents6" id="bodyContents699">Inference (Decoding and Rescoring):</strong></p>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents6" id="bodyContents610">Parameters:</strong></dt>
      <dd>
        <ul>
          <li><strong>Momentum</strong>: \(0.99\)</li>
          <li><strong>Dropout</strong>: \(5-10 \%\) (FFN only)</li>
          <li><strong>Trade-Off Params</strong>: use cross-validation for \(\alpha, \beta\)</li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents6" id="bodyContents611">Issues/The Bottleneck:</strong></dt>
      <dd></dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents6" id="bodyContents612">Results:</strong></dt>
      <dd>
        <ul>
          <li><strong>SwitchboardHub5’00</strong>  (
WER):
            <ul>
              <li>Standard: \(16.0\%\)</li>
              <li>w/Lexicon of allowed words: \(21.9\%\)</li>
              <li>Trigram LM: \(8.2\%\)</li>
              <li>w/Baseline system: \(6.7\%\)</li>
            </ul>
          </li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents6" id="bodyContents613">Discussion:</strong></dt>
      <dd>
        <ul>
          <li>Without the attention mechanism, the model overfits the training data significantly, in spite of our large training set of three million utterances - it memorizes the training transcripts without paying attention to the acoustics.</li>
          <li>Without the pyramid structure in the encoder side, our model converges too slowly - even after a month of training, the error rates were significantly higher than the errors reported</li>
          <li>To reduce the overfitting of the speller to the training transcripts, use a sampling trick during training</li>
        </ul>
      </dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><strong style="color: SteelBlue" class="bodyContents6" id="bodyContents614">Further Development:</strong></dt>
      <dd></dd>
    </dl>
  </li>
</ol>

<hr />
<!-- 
## Seven
{: #content7}

1. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents7 #bodyContents71}  
    :   

2. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents7 #bodyContents72}  
    :   

3. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents7 #bodyContents73}  
    :   

4. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents7 #bodyContents74}  
    :   

5. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents7 #bodyContents75}  
    :   

6. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents7 #bodyContents76}  
    :   

7. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents7 #bodyContents77}  
    :   

8. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents7 #bodyContents78}  
    :   

## Eight
{: #content8}

1. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents8 #bodyContents81}  
    :   

2. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents8 #bodyContents82}  
    :   

3. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents8 #bodyContents83}  
    :   

4. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents8 #bodyContents84}  
    :   

5. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents8 #bodyContents85}  
    :   

6. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents8 #bodyContents86}  
    :   

7. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents8 #bodyContents87}  
    :   

8. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents8 #bodyContents88}  
    :   

## Nine
{: #content9}

1. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents9 #bodyContents91}  
    :   

2. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents9 #bodyContents92}  
    :   

3. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents9 #bodyContents93}  
    :   

4. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents9 #bodyContents94}  
    :   

5. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents9 #bodyContents95}  
    :   

6. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents9 #bodyContents96}  
    :   

7. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents9 #bodyContents97}  
    :   

8. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents9 #bodyContents98}  
    :   

## Ten
{: #content10}

1. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents10 #bodyContents101}  
    :   

2. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents10 #bodyContents102}  
    :   

3. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents10 #bodyContents103}  
    :   

4. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents10 #bodyContents104}  
    :   

5. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents10 #bodyContents105}  
    :   

6. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents10 #bodyContents106}  
    :   

7. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents10 #bodyContents107}  
    :   

8. **Asynchronous:**{: style="color: SteelBlue"}{: .bodyContents10 #bodyContents108}  
    :   

 -->


      <footer class="site-footer">
    <!--   <span class="site-footer-owner"><a href="http://localhost:8889">Ahmad Badary</a> is maintained by <a href="https://ahmedbadary.github.io/">Ahmad Badary</a>.</span> -->
    
<!--  -->
    <div class="wrapper">
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
            <span class="site-footer-owner"><a href="http://localhost:8889">Site</a> maintained by <a href="https://ahmedbadary.github.io/">Ahmad Badary</a>.</span>
    <span class="site-footer-credits">
        <p>
            &copy; 2017. All rights reserved.
        </p> 
    </span>
            </div>
            <div class="footer-col footer-col-2">
            <div><p>         </p></div>
            </div>
            <div class="footer-col footer-col-3">
                <ul class="social-media-list">
                    
                      <li>
                        <a href="https://github.com/AhmedBadary">
                          <i class="fa fa-github"></i> GitHub
                        </a>
                      </li>
                    
                    
                      <li>
                        <a href="https://linkedin.com/in/ahmad-badary-656098121/">
                          <i class="fa fa-linkedin"></i> LinkedIn
                        </a>
                      </li>
                    
                    
                      <li>
                        <a href="https://www.facebook.com/ahmed.thabet.94">
                          <i class="fa fa-facebook"></i> Facebook
                        </a>
                      </li>
                    
                </ul>
            </div>
        </div>
    </div>
<!--  -->
</footer>


    </section>

  </body>

<!-- Table of Content Script -->
<script type="text/javascript">
var bodyContents = $(".bodyContents1");
$("<ol>").addClass("TOC1ul").appendTo(".TOC1");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC1ul");
     });
// 
var bodyContents = $(".bodyContents2");
$("<ol>").addClass("TOC2ul").appendTo(".TOC2");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC2ul");
     });
// 
var bodyContents = $(".bodyContents3");
$("<ol>").addClass("TOC3ul").appendTo(".TOC3");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC3ul");
     });
//
var bodyContents = $(".bodyContents4");
$("<ol>").addClass("TOC4ul").appendTo(".TOC4");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC4ul");
     });
//
var bodyContents = $(".bodyContents5");
$("<ol>").addClass("TOC5ul").appendTo(".TOC5");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC5ul");
     });
//
var bodyContents = $(".bodyContents6");
$("<ol>").addClass("TOC6ul").appendTo(".TOC6");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC6ul");
     });
//
var bodyContents = $(".bodyContents7");
$("<ol>").addClass("TOC7ul").appendTo(".TOC7");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC7ul");
     });
//
var bodyContents = $(".bodyContents8");
$("<ol>").addClass("TOC8ul").appendTo(".TOC8");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC8ul");
     });
//
var bodyContents = $(".bodyContents9");
$("<ol>").addClass("TOC9ul").appendTo(".TOC9");
bodyContents.each(function(index, element) {
    var paragraph = $(element);
    $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC9ul");
     });

</script>

<!-- VIDEO BUTTONS SCRIPT -->
<script type="text/javascript">
  function iframePopInject(event) {
    var $button = $(event.target);
    // console.log($button.parent().next());
    if ($button.attr('value') == 'show') {
        $button.attr('value', 'hide');
        $figure = $("<div>").addClass("video_container");
        $iframe = $("<iframe>").appendTo($figure);
        $iframe.attr("src", $button.attr("src"));
        // $iframe.attr("frameborder", "0");
        $iframe.attr("allowfullscreen", "true");
        $iframe.css("padding", "4px 6px");
        $button.next().css("display", "block");
        $figure.appendTo($button.next());
        $button.text("Hide Video")
    } else {
        $button.attr('value', 'show');
        $button.next().html("");
        $button.text("Show Video")
    }
}
</script>

<!-- BUTTON TRY -->
<script type="text/javascript">
  function iframePopA(event) {
    event.preventDefault();
    var $a = $(event.target).parent();
    console.log($a);
    if ($a.attr('value') == 'show') {
        $a.attr('value', 'hide');
        $figure = $("<div>");
        $iframe = $("<iframe>").addClass("popup_website_container").appendTo($figure);
        $iframe.attr("src", $a.attr("href"));
        $iframe.attr("frameborder", "1");
        $iframe.attr("allowfullscreen", "true");
        $iframe.css("padding", "4px 6px");
        $a.next().css("display", "block");
        $figure.appendTo($a.next().next());
        // $a.text("Hide Content")
        $('html, body').animate({
            scrollTop: $a.offset().top
        }, 1000);
    } else {
        $a.attr('value', 'show');
        $a.next().next().html("");
        // $a.text("Show Content")
    }

    $a.next().css("display", "inline");
}
</script>


<!-- TEXT BUTTON SCRIPT - INJECT -->
<script type="text/javascript">
  function showTextPopInject(event) {
    var $button = $(event.target);
    var txt = $button.attr("input");
    console.log(txt);
    if ($button.attr('value') == 'show') {
        $button.attr('value', 'hide');
        $p = $("<p>");
        $p.html(txt);
        $button.next().css("display", "block");
        $p.appendTo($button.next());
        $button.text("Hide Content")
    } else {
        $button.attr('value', 'show');
        $button.next().html("");
        $button.text("Show Content")
    }

}
</script>

<!-- TEXT BUTTON SCRIPT - HIDDEN / HIDE / SHOW / HIDE/SHOW -->
<script type="text/javascript">
  function showTextPopHide(event) {
    var $button = $(event.target);
    // var txt = $button.attr("input");
    var txt = $button.text();
    if ($button.attr('value') == 'show') {
        $button.attr('value', 'hide');
        $button.next().removeAttr("hidden");
        $button.text(txt + " - Hide Content");
    } else {
        $button.attr('value', 'show');
        $button.next().attr("hidden", "");
        $button.text(txt.replace(" - Hide Content",""));
    }
}
</script>

<!-- TEXT BUTTON SCRIPT - HIDDEN / HIDE / SHOW / HIDE/SHOW -->
<script type="text/javascript">
  function showText_withParent_PopHide(event) {
    var $button = $(event.target);
    var $parent = $button.parent();
    var txt = $button.text();
    if ($button.attr('value') == 'show') {
        $button.attr('value', 'hide');
        $parent.next().removeAttr("hidden");
        $button.text(txt + " - Hide Content");
    } else {
        $button.attr('value', 'show');
        $parent.next().attr("hidden", "");
        $button.text(txt.replace(" - Hide Content",""));
    }
}
</script>

<!-- Print / Printing / printme -->
<!-- <script type="text/javascript">
i = 0

for (var i = 1; i < 6; i++) {
    var bodyContents = $(".bodyContents" + i);
    $("<p>").addClass("TOC1ul")  .appendTo(".TOC1");
    bodyContents.each(function(index, element) {
        var paragraph = $(element);
        $("<li>").html("<a href=#"+paragraph.attr('id')+">"+ paragraph.html().replace(':','')+" </a> ").appendTo(".TOC1ul");
         });
} 
</script>
 -->
 
</html>

